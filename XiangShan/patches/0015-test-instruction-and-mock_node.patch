From d7b11961ef180ce63341dfe0e96588734144c5ae Mon Sep 17 00:00:00 2001
From: mlabaf <mlabaf@gmail.com>
Date: Thu, 29 Aug 2024 15:02:16 +0800
Subject: [PATCH 15/16] test instruction and mock_node

---
 src/main/scala/xiangshan/backend/fu/Alu.scala | 2742 +++++++++--------
 1 file changed, 1428 insertions(+), 1314 deletions(-)

diff --git a/src/main/scala/xiangshan/backend/fu/Alu.scala b/src/main/scala/xiangshan/backend/fu/Alu.scala
index 489fbfdaf..0b22bc63f 100644
--- a/src/main/scala/xiangshan/backend/fu/Alu.scala
+++ b/src/main/scala/xiangshan/backend/fu/Alu.scala
@@ -123,12 +123,12 @@ import circt.stage.ChiselStage
 
 
 //////////////////////////////////////node/////////////////
- class node_mut_t extends Bundle{
+class node_mut_t extends Bundle{
    val node_id = cap_renode_id_t 
    val node_op = UInt (4.W)//node_mut_type_t 
    val alloc   = UInt (1.W)  
    val new_node_id = cap_renode_id_t 
-  } 
+} 
 
   // mutation does not require a response
 
@@ -145,7 +145,7 @@ class node_query_resp_t extends Bundle{
   } 
 
 class send_node_query_bundle extends Bundle
-   {
+  {
     val revnode_id                 = Input(cap_renode_id_t)
     val node_query_sent_q          = Input(UInt(1.W))
     val node_query_ready_i         = Input(UInt(1.W))
@@ -161,10 +161,10 @@ class send_node_query_bundle extends Bundle
     val node_query_resp_result_d   = Output(UInt(1.W))
     val node_query_resp_received_d = Output(UInt(1.W))
     val node_query_resp_result_q   = Output(UInt(1.W))
-   }
+  }
    
-  class send_node_query extends Module
-   {
+class send_node_query extends Module
+  {
     val ins    =IO(new send_node_query_bundle )
 
      ins.node_query_sent_d          := 0.U
@@ -218,7 +218,7 @@ class send_node_query_bundle extends Bundle
       }
      }
 
-     when (ins.synchronous===1.U) 
+     .elsewhen (ins.synchronous===1.U) 
       {
       when (ins.node_query_resp_received_q===0.U) 
         {
@@ -257,10 +257,10 @@ class send_node_query_bundle extends Bundle
     //  ins.node_query_resp_received_d := 0.U
     //  ins.node_query_resp_result_q   := 0.U
     //  } 
-    }
+}
 
-   class send_node_mut_bundle extends Bundle 
-   {
+class send_node_mut_bundle extends Bundle 
+  {
     // this reuses capstone_valid_o so it's safe to always set node_mut_valid_o
     val revnode_id       = Input( cap_renode_id_t)
     val node_alloc_node_id_cur = Input( cap_renode_id_t)
@@ -269,10 +269,10 @@ class send_node_query_bundle extends Bundle
 
     val node_mut_valid_o = Output(UInt(1.W))
     val node_mut_o       = Output(new node_mut_t)   
-   }  
+  }  
 
-   class send_node_mut extends Module 
-   {
+class send_node_mut extends Module 
+  {
      val ins  =IO(new send_node_mut_bundle )
 
     // this reuses capstone_valid_o so it's safe to always set node_mut_valid_o
@@ -288,28 +288,29 @@ class send_node_query_bundle extends Bundle
      ins.node_mut_o.node_op:= ins.mut_ty
      ins.node_mut_o.alloc  := ins.have_alloc
      ins.node_mut_o.new_node_id:= ins.node_alloc_node_id_cur
-   }
+  }
 
-  class send_node_alloc_bundle extends Bundle 
+class send_node_alloc_bundle extends Bundle 
   {
     // this reuses capstone_valid_o so it's safe to always set node_mut_valid_o
-    val node_alloc_state_d   = Output( UInt(4.W))//IO(Output(new node_mut_type_t))
-    // val node_mut_valid_o     = IO(Output(UInt(1.W)))
-    // val node_alloc_node_id_d = IO(Output(new node_mut_t))  
-    val node_alloc_valid_o   = Output(UInt(1.W)) 
-    val node_alloc_ready_i   = Input(UInt(1.W))
-    val node_alloc_state_q   = Input(UInt(4.W))
-    // val node_alloc_node_id_q = IO(Input(UInt(1.W)))     
-    // val cap_cc               = IO(Input( new cap_cc_t))
+    val node_alloc_state_d      = Output( UInt(4.W))//IO(Output(new node_mut_type_t))
+    val node_alloc_valid_o      = Output(UInt(1.W)) 
+    val node_alloc_node_id_d    = Output(UInt(1.W)) 
+
+    val node_alloc_ready_i      = Input(UInt(1.W))
+    val node_alloc_state_q      = Input(UInt(4.W))
+    val node_alloc_resp_valid_i = Input(UInt(1.W))
+    val node_alloc_node_id_i    = Input(UInt(1.W))
   }
 
-  class send_node_alloc extends Module 
+class send_node_alloc extends Module 
   {
     val ins  =IO(new send_node_alloc_bundle )
 
     // this reuses capstone_valid_o so it's safe to always set node_mut_valid_o
-    ins.node_alloc_state_d:=0.U
-    ins.node_alloc_valid_o:=0.U
+    ins.node_alloc_state_d  :=0.U
+    ins.node_alloc_valid_o  :=0.U
+    ins.node_alloc_node_id_d:=0.U
 
    switch (ins.node_alloc_state_q)
     {
@@ -323,7 +324,12 @@ class send_node_query_bundle extends Bundle
       }
       is (mut_t.NODE_ALLOC_SENT) 
       {
-        // special treatment later
+        when(ins.node_alloc_resp_valid_i===1.U)
+        {
+          ins.node_alloc_node_id_d:=ins.node_alloc_node_id_i
+          ins.node_alloc_state_d  :=mut_t.NODE_ALLOC_RECEIVED
+
+        }
       }
       is (mut_t.NODE_ALLOC_RECEIVED) 
       {
@@ -332,7 +338,7 @@ class send_node_query_bundle extends Bundle
     }
   }
 
- class wait_for_this_cycle_bundle extends Bundle 
+class wait_for_this_cycle_bundle extends Bundle 
   {
     val capstone_valid_o    = Output(UInt(1.W))
     val cms_result_o        = Output(new capstone_mode_switch_t) 
@@ -344,7 +350,7 @@ class send_node_query_bundle extends Bundle
     val fu_data_cur         = Input(new fu_data_t)
   }
 class wait_for_this_cycle extends Module 
-{
+ {
   val ins  =IO(new wait_for_this_cycle_bundle )
   ins.capstone_valid_o := 0.U
   ins.cms_result_o     := 0.U
@@ -352,7 +358,7 @@ class wait_for_this_cycle extends Module
   ins.valid_last_n      := 0.U
   ins.pc_last_n         := ins.pc_cur
   ins.fu_data_last_n    := ins.fu_data_cur
-}    
+ }    
   
 ////////////////////////////////////////////////////////capstone class end //////////////////////////////////
 
@@ -376,34 +382,26 @@ class  cap_bounds_uncompres extends Module {
   B := Cat(cap_cc_bounds.b(10,0),0.U(3.W)) 
   T := Cat(0.U(2.W),cap_cc_bounds.t(8,0),0.U(3.W)) 
 
-// val b_iE= Bool(cap_cc_bounds.iE)
-//  if (cap_cc_bounds.iE===0.U )
-//  if (cap_cc_bounds.iE==0.U )
- when (cap_cc_bounds.iE===0.U )
-  {
-      // printf("cap_bounds_uncompres cap_cc_bounds.iE=0 \n")
-
+  // val b_iE= Bool(cap_cc_bounds.iE)
+   when (cap_cc_bounds.iE===0.U )
+   {
       E := 0.U(6.W)
       T1 := Cat(T(13,3),cap_cc_bounds.tE(2,0) ) 
       B1 := Cat(B(13,3),cap_cc_bounds.bE(2,0) ) 
       msb := 0.U
-      // carry_out := Mux(T(11,0) < B(11,0), true.B, false.B)
       carry_out := Mux(T(11,0) < B(11,0), 1.U, 0.U)
-  }    
-  // else
-//  when (cap_cc_bounds.iE=/=0.U )
+   }    
+  //  when (cap_cc_bounds.iE=/=0.U )
   .otherwise
-  {
-  //  printf("cap_bounds_uncompres cap_cc_bounds.iE=1 \n")
-
+   {
    E := Cat(cap_cc_bounds.tE(2,0), cap_cc_bounds.bE(2,0) ) 
    T1 := Cat(T(13,3),0.U(3.W)) 
    B1 := Cat(B(13,3),0.U(3.W)) 
    carry_out := Mux(T(11,3) < B(11,3), 1.U, 0.U)
    msb := 1.U
-  }
+  } 
 
-  //  T(13,12) := B(13,12) + Cat(0.U(1.W), carry_out) + Cat(0.U(1.W), msb)   
+   //  T(13,12) := B(13,12) + Cat(0.U(1.W), carry_out) + Cat(0.U(1.W), msb)   
     val K = B1(13,12) + Cat(0.U(1.W), carry_out) + Cat(0.U(1.W), msb)
     T2 := Cat(K,T1(11,0))
 
@@ -421,14 +419,12 @@ class  cap_bounds_uncompres extends Module {
    val k3 = (cap_cc_bounds.cursor) >> (E + 11.U(6.W))
    A3 := k3(2,0)
    T3 := T2(13,11)//Cat(T(13,11)) 
-   B3 := B1(13,11)//Cat(B(13,11))   
+   B3 := B1(13,11)  
    R  := B3 - 1.U(3.W)       
 
   val tt4 = Mux((A3 >= R) && (T3 < R), tt2 + (1.U(64.W) << (E + 14.U(6.W))), (Mux(((A3 < R) && (T3 >= R)), tt2 - (1.U(64.W) << (E + 14.U(6.W))),tt2 ))) //?        
   val bb4 = Mux((A3 >= R) && (B3 < R), bb2 + (1.U(64.W) << (E + 14.U(6.W))), (Mux(((A3 < R) && (B3 >= R)), bb2 - (1.U(64.W) << (E + 14.U(6.W))),bb2 ))) //?   
- 
-  // printf("cap_bounds_uncompres4 bb/=  %b -\n",bb4)
-  // printf("cap_bounds_uncompres tt/=  %b -\n",tt4)
+
 
   cap_fat_bounds.cursor:= cap_cc_bounds.cursor
   cap_fat_bounds.base  := bb4
@@ -441,60 +437,78 @@ class cap_bounds_compress extends Module {
 
   val cap_cc_bounds  =IO(Output(new cap_cc_bounds_t))
   val cap_fat_bounds =IO(Input(new cap_fat_bounds_t))
-  // val cap_cc_bounds  =Wire(new cap_cc_bounds_t)
-  // val cap_fat_bounds =Wire(new cap_fat_bounds_t)
 
   val leading_zeros = Reg(UInt(6.W))//63.U(6.W)//??//UInt(6.W)// 0.U//"b000000".U(6.W)//VecInit.fill(6)(true.B)// //VecInit.fill(6)(true.B) //Vec(6, Bool())
-  val E  = Reg(UInt(6.W))//Wire(UInt(6.W)) //Vec(6, Bool())
-  val iE = WireInit(0.U(1.W))//Wire(UInt(1.W)) //Bool()// 63
-  val B1  = WireInit(0.U(14.W))//Wire(UInt(14.W)) //  Vec(14, Bool())
-  val T1  = WireInit(0.U(12.W))//Wire(UInt(12.W)) //Vec(12, Bool())
-  val len = Wire(UInt(64.W))
+  val E  = Reg(UInt(6.W))
+  val iE = WireInit(0.U(1.W))
+  val B1  = WireInit(0.U(14.W))
+  val T1  = WireInit(0.U(12.W))
   val test2 = Reg(UInt(64.W))
  
   val test4,test1 =Reg(Bool())
-  val test3 =Reg(Bool())
+  val test3 =Reg(Bool())  
+  
+  val len = Wire(UInt(64.W))
   len:= cap_fat_bounds.top - cap_fat_bounds.base 
-  leading_zeros := 63.U//?
+  
+  leading_zeros := 63.U
 
   E:= 0.U
   //  val test1=(leading_zeros > 12.U(6.W)) && ((len >> leading_zeros) & 1.U(XLEN.W))
+  test1:=(leading_zeros > 12.U(6.W)) 
+  test2:=(len >> leading_zeros)
+  test3:=Mux(test2(0),false.B,true.B)
+  test4:= test1 && test3
+   
+  printf("after for : %b, %b \n", cap_fat_bounds.top, cap_fat_bounds.base )
+
+  // // while(((leading_zeros > 12.U(6.W)) & ((len >> leading_zeros) & 1.U(XLEN.W))) === 0.U(XLEN.W)) 
+  // when(test4)
+  // {//to find first msb '1'
+  //   leading_zeros := leading_zeros - 1.U
+  //   test1:=(leading_zeros > 12.U(6.W)) 
+  //   test2:=(len >> leading_zeros)
+  //   test3:=Mux(test2(0),false.B,true.B)
+  //   test4:= test1 && test3
+  // }
+  // printf("after for1: %b, %b , %b \n", leading_zeros, test4 , len )
+
+ 
+ 
+  var flag = 0
+  var leading_zeross = 63
+  var lenn =196//cap_fat_bounds.top - cap_fat_bounds.base//196//5439//196//len.litValue
+  var k = lenn
+  for (i <- 0 until 52)//63-11
+  {
+    if (lenn<4096)
+    {
+      leading_zeross=12
+      flag=1
+    }
+    else if (flag==0)
+    {
+     if ((leading_zeross > 12) && ((lenn>> leading_zeross) == 0))
+      {
+       leading_zeross = leading_zeross - 1
+       k = lenn>> leading_zeross
+       printf("after for3: %b ,%b , %b , %b \n", leading_zeross.U, flag.U,i.U, k.U)
 
-    test1:=(leading_zeros > 12.U(6.W)) 
-    test2:=(len >> leading_zeros)
-    test3:=Mux(test2(0),false.B,true.B)//?
-  //  val test4= test1 && test3
-  //  val test4 =Reg(false.B)
-   test4:= test1 && test3
-//   val test5=(leading_zeros > 12.U(6.W))&& Mux(test2(0),false.B,true.B)
-
-  // printf("cap_bounds_compress test4=%b\n",test4 )
-
- // while(((leading_zeros > 12.U(6.W)) & ((len >> leading_zeros) & 1.U(XLEN.W))) === 0.U(XLEN.W)) 
-
-// Timer FSM (down counter)
-// while ((test1 && test3)==1.U ) 
-  //  while(test4==true.B)
-  //  while(test4==1.U)
-    // while(test4==true.B)
-  // while(test4==1.U)
- // while(test1 && test3)
-  //{
-  when(test4)
-  {//to find first msb '1'
-    leading_zeros := leading_zeros - 1.U
-    test1:=(leading_zeros > 12.U(6.W)) 
-    test2:=(len >> leading_zeros)
-    test3:=Mux(test2(0),false.B,true.B)
-    test4:= test1 && test3
-    // printf("cap_bounds_compress leading_zeros2=%b,%b,%b,%b\n",test1, test2, test3,leading_zeros)
+      }
+      else 
+      {
+       flag=1
+      }
+    }
   }
-  E := leading_zeros - 12.U(6.W)
-  // printf("cap_bounds_compress E=%b\n",E )
-  // printf("cap_bounds_compress leading_zeros4=%b\n",leading_zeros )
 
+  printf("after for2: %b ,%b , %b ,%b,%b,  \n", leading_zeross.U, flag.U, len, E,len(12))
+
+
+
+  // E := leading_zeros - 12.U(6.W)
+  E := leading_zeross.U - 12.U(6.W)
 
-  // if((E ==0.U(6.W))&&(len(12) == 0.U(1.W))) 
   when((E ===0.U(6.W))&&(len(12) === 0.U(1.W))) 
    {
     iE := 0.U
@@ -519,28 +533,33 @@ class cap_bounds_compress extends Module {
     else 
       T1:=Cat(k2(11,3),E(5,3))
 
-    // printf("cap_bounds_compress len 12 zero2" )
     // TODO: more corrections
   }
 
   cap_cc_bounds.cursor:= cap_fat_bounds.cursor
 
-  cap_cc_bounds.bE:= B1(2,0)
-  cap_cc_bounds.b:= B1(13,3)
-  cap_cc_bounds.tE:= T1(2,0)
-  cap_cc_bounds.t:= T1(11,3)
+  cap_cc_bounds.bE := B1(2,0)
+  cap_cc_bounds.b  := B1(13,3)
+  cap_cc_bounds.tE := T1(2,0)
+  cap_cc_bounds.t  := T1(11,3)
 }
 
 // converts a compressed cap into a fat cap
 class cap_uncompress extends Module {
 
-  val cap_fat =IO(Output(new cap_fat_t))
-  val cap_cc  =IO(Input(new cap_cc_t))
+ val cap_fat =IO(Output(new cap_fat_t))
+ val cap_cc  =IO(Input(new cap_cc_t))
  
-  val  cap_uncompress_cap = Module( new cap_bounds_uncompres)
-if ((cap_cc.meta.ty == cap_type_t.CAP_TYPE_SEALED )||(cap_cc.meta.ty == cap_type_t.CAP_TYPE_SEALEDRET)) 
-{ 
-      // printf("cap_uncompress IF 1")
+ val  cap_uncompress_cap = Module( new cap_bounds_uncompres)
+ //  if ((cap_cc.meta.ty == cap_type_t.CAP_TYPE_SEALED )||(cap_cc.meta.ty == cap_type_t.CAP_TYPE_SEALEDRET)) 
+ when ((cap_cc.meta.ty === cap_type_t.CAP_TYPE_SEALED )||(cap_cc.meta.ty === cap_type_t.CAP_TYPE_SEALEDRET)) 
+ { 
+  cap_uncompress_cap.cap_cc_bounds.iE := 0.U  
+  cap_uncompress_cap.cap_cc_bounds.t  := 0.U      
+  cap_uncompress_cap.cap_cc_bounds.tE := 0.U     
+  cap_uncompress_cap.cap_cc_bounds.b  := 0.U      
+  cap_uncompress_cap.cap_cc_bounds.bE := 0.U      
+  cap_uncompress_cap.cap_cc_bounds.cursor := 0.U 
 
   cap_fat.bounds.cursor:= 0.U
   cap_fat.bounds.base:= cap_cc.bounds.cursor
@@ -552,9 +571,9 @@ if ((cap_cc.meta.ty == cap_type_t.CAP_TYPE_SEALED )||(cap_cc.meta.ty == cap_type
   cap_fat.meta.perm:= cap_cc.meta.perm
   cap_fat.renode_id:= cap_cc.renode_id
  }
- else
+ //  else
+ .otherwise
  {
-        // printf("cap_uncompress IF 2")
 
   cap_uncompress_cap.cap_cc_bounds.iE := cap_cc.bounds.iE   
   cap_uncompress_cap.cap_cc_bounds.t  := cap_cc.bounds.t     
@@ -577,21 +596,23 @@ if ((cap_cc.meta.ty == cap_type_t.CAP_TYPE_SEALED )||(cap_cc.meta.ty == cap_type
 }
 
 // converts a fat cap into a compressed cap
- class cap_compress extends Module {
-
+class cap_compress extends Module {
   val cap_fat =IO(Input(new cap_fat_t()))
   val cap_cc  =IO(Output(new cap_cc_t()))
   val cap_compress_cap = Module( new cap_bounds_compress)
-  // val bounds_cc =  (new cap_cc_bounds_t)
-  //val bounds_cc =  Wire(new cap_cc_bounds_t)
 
-  if ((cap_fat.meta.ty == cap_type_t.CAP_TYPE_SEALED) || (cap_fat.meta.ty == cap_type_t.CAP_TYPE_SEALEDRET)) 
+
+  // if ((cap_fat.meta.ty == cap_type_t.CAP_TYPE_SEALED) || (cap_fat.meta.ty == cap_type_t.CAP_TYPE_SEALEDRET)) 
+  when ((cap_fat.meta.ty === cap_type_t.CAP_TYPE_SEALED) || (cap_fat.meta.ty === cap_type_t.CAP_TYPE_SEALEDRET)) 
   {
   // printf("cap_compress  if 1")
 
   // we don't need to store full bounds. Instead, we reuse the bits
   // for async and reg
-
+  cap_compress_cap.cap_fat_bounds.top    :=0.U
+  cap_compress_cap.cap_fat_bounds.base   :=0.U
+  cap_compress_cap.cap_fat_bounds.cursor :=0.U
+  
   //  cap_cc.bounds:= 0.U
    cap_cc.meta.ty:= cap_fat.meta.ty
    cap_cc.meta.perm:= cap_fat.meta.perm
@@ -605,10 +626,9 @@ if ((cap_cc.meta.ty == cap_type_t.CAP_TYPE_SEALED )||(cap_cc.meta.ty == cap_type
 
 
   }
-  else 
+  // else 
+  .otherwise
    {
-    //  printf("cap_compress  if 2")
-
      cap_compress_cap.cap_fat_bounds.top    :=cap_fat.bounds.top
      cap_compress_cap.cap_fat_bounds.base   :=cap_fat.bounds.base
      cap_compress_cap.cap_fat_bounds.cursor :=cap_fat.bounds.cursor
@@ -628,12 +648,10 @@ if ((cap_cc.meta.ty == cap_type_t.CAP_TYPE_SEALED )||(cap_cc.meta.ty == cap_type
 
 class cap_cc_set_async_reg_id extends Module {
 
-  val async   =  IO(Input(0.U(1.W)))//Bool()
-  val reg_id  =  IO(Input(0.U(5.W)))//Vec(5, Bool())
+  val async   =  IO(Input(0.U(1.W)))
+  val reg_id  =  IO(Input(0.U(5.W)))
   val cap_cc_n= IO(Output(new cap_cc_t()))
   val cap_cc  =  IO(Input (new cap_cc_t()))
-  // val cap_cc_n= Wire(new cap_cc_t())
-  // val cap_cc  = Wire (new cap_cc_t())
 
     cap_cc_n := cap_cc;
     cap_cc_n.bounds.b(5,1) := reg_id
@@ -644,17 +662,14 @@ class cap_cc_set_async_reg_id extends Module {
 class cap_cc_get_async  extends Module {
  
   val cap_cc =IO(Input(new cap_cc_t()))
-  // val cap_cc =Wire(new cap_cc_t())
-
-  val Outputt=IO(Output(0.U(1.W)))//(Bool())
-
+  val Outputt=IO(Output(0.U(1.W)))
    Outputt := cap_cc.bounds.b(0)
 }
 
 class cap_cc_is_cap extends Module { 
   val cap_cc =IO(Input(new cap_cc_t()))
   // val cap_cc =Wire(new cap_cc_t())
-  val out    =IO(Output(0.U(1.W)))//Bool()
+  val out    =IO(Output(0.U(1.W)))
   
     out:= cap_cc; // FIXME: temporary hack//??
   }
@@ -668,7 +683,6 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
   val crevoke2  = IO(Output(new cap_result_t ))
   val  ex_o_v   = IO(Output (UInt(1.W) ))
 
-  // io.rd_result_o.tag:= 1.U(1.W)
   //node port
    val send_node_query_ins  =IO(new send_node_query_bundle())
    val send_node_mut_ins    =IO(new send_node_mut_bundle())
@@ -687,15 +701,15 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    val cap_uncompress_cap = Module(new cap_uncompress)
    val cap_compress_cap   = Module(new cap_compress)
 
-   rs1_cc.renode_id  := Cat(src.cap_a(30,0))//31
-   rs1_cc.meta.ty    := Cat(src.cap_a(33,31)) //6
-   rs1_cc.meta.perm  := Cat(src.cap_a(36,34)) //6  
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37))    //1
-   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   rs1_cc.renode_id  := src.cap_a(30,0)//31
+   rs1_cc.meta.ty    := src.cap_a(33,31) //6
+   rs1_cc.meta.perm  := src.cap_a(36,34) //6  
+   rs1_cc.bounds.iE  := src.cap_a(37)    //1
+   rs1_cc.bounds.t   := src.cap_a(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+   rs1_cc.bounds.b   := src.cap_a(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_a(127,64)//64
 
    cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
    cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
@@ -723,16 +737,13 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
 
 
 
-  printf("revoke origin type is=%b , %b\n",rs1_cc.meta.ty , src.tag_a)
+  printf("revoke origin type is=%b\n",rs1_cc.meta.ty)
 
-//  if ((src.tag_a==0.U) && (rs1_cc.meta.ty == cap_type_t.CAP_TYPE_REVOKE))
   when ((src.tag_a===0.U) && (rs1_cc.meta.ty === cap_type_t.CAP_TYPE_REVOKE))
-    {
+  {
 
-    cap_compress_cap.cap_fat.meta.ty:=cap_type_t.CAP_TYPE_LINEAR
-    // rs1_result_o = '{ cap: 128'(rs1_cc), tag: 1'b1, valid: 1'b1 };
+   cap_compress_cap.cap_fat.meta.ty:=cap_type_t.CAP_TYPE_LINEAR
 
-  //  rs1_cc = capstone::cap_compress(rs1_c);
    cap_compress_cap.cap_fat.bounds.base  :=rs1_c.bounds.base
    cap_compress_cap.cap_fat.bounds.top   :=rs1_c.bounds.top  
    cap_compress_cap.cap_fat.bounds.cursor:=rs1_c.bounds.cursor
@@ -753,8 +764,8 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
 
 
 
-  // rd_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};    
-    crevoke.cap  := Cat(rs2_cc.renode_id,rs2_cc.meta.ty,rs2_cc.meta.perm,rs2_cc.bounds.iE , rs2_cc.bounds.t , rs2_cc.bounds.tE , rs2_cc.bounds.b , rs2_cc.bounds.bE ,rs2_cc.bounds.cursor )
+  // rd_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1}; 
+    crevoke.cap  := Cat(rs2_cc.bounds.cursor , rs2_cc.bounds.bE , rs2_cc.bounds.b , rs2_cc.bounds.tE , rs2_cc.bounds.t , rs2_cc.bounds.iE , rs2_cc.meta.perm, rs2_cc.meta.ty , rs2_cc.renode_id )
     crevoke.tag  := 1.U(1.W)
     crevoke.valid:= 1.U(1.W) 
 
@@ -763,13 +774,13 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
     send_node_query_c.ins.revnode_id:=rs2_cc.renode_id
     send_node_query_c.ins.synchronous:=0.U
     //initial
-    send_node_query_c.ins.node_query_sent_q          := 0.U
-    send_node_query_c.ins.node_query_ready_i         := 0.U
-    send_node_query_c.ins.node_query_resp_valid_i    := 0.U
-    send_node_query_c.ins.node_query_resp_received_q := 0.U 
-    send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
-    send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
-    send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U  
+    // send_node_query_c.ins.node_query_sent_q          := 0.U
+    // send_node_query_c.ins.node_query_ready_i         := 0.U
+    // send_node_query_c.ins.node_query_resp_valid_i    := 0.U
+    // send_node_query_c.ins.node_query_resp_received_q := 0.U 
+    // send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
+    // send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
+    // send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U  
 
     send_node_mut_c.ins.revnode_id:=rs2_cc.renode_id
     send_node_mut_c.ins.mut_ty:=node_mut_type_t.NODE_REVOKE
@@ -808,9 +819,9 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    crevoke2.tag  := 0.U(1.W)
    crevoke2.valid:= 0.U(1.W)  
 
-  }
+}
 
-  class cshrinkModule(implicit p: Parameters) extends XSModule {
+class cshrinkModule(implicit p: Parameters) extends XSModule {
     val src      = IO(Input(new fu_data_t))
     val cshrink  = IO(Output(new cap_result_t )) 
     val cshrink2 = IO(Output(new cap_result_t )) 
@@ -820,18 +831,19 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
 
    //unpacked capability
    val rs1_cc =Reg(new cap_cc_t)  
+   val rs2_cc =Reg(new cap_cc_t)  
    val rs1_c  =Reg(new cap_fat_t)
    val cursor =Wire(UInt(XLEN.W))
 
-   rs1_cc.renode_id  := Cat(src.cap_c(30,0))//31
-   rs1_cc.meta.ty    := Cat(src.cap_c(33,31)) //6
-   rs1_cc.meta.perm  := Cat(src.cap_c(36,34)) //6  
-   rs1_cc.bounds.iE  := Cat(src.cap_c(37))    //1
-   rs1_cc.bounds.t   := Cat(src.cap_c(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_c(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_c(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_c(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_c(127,64)) //64
+   rs1_cc.renode_id  := src.cap_c(30,0)//31
+   rs1_cc.meta.ty    := src.cap_c(33,31) //6
+   rs1_cc.meta.perm  := src.cap_c(36,34) //6  
+   rs1_cc.bounds.iE  := src.cap_c(37)    //1
+   rs1_cc.bounds.t   := src.cap_c(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_c(49,47) //3
+   rs1_cc.bounds.b   := src.cap_c(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_c(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_c(127,64)//64
    
   val cap_uncompress_cap=Module(new cap_uncompress)
   val cap_compress_cap  =Module(new cap_compress)
@@ -847,10 +859,14 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    cap_uncompress_cap.cap_cc.meta.ty     :=rs1_cc.meta.ty
    cap_uncompress_cap.cap_cc.meta.perm   :=rs1_cc.meta.perm
    cap_uncompress_cap.cap_cc.renode_id   :=rs1_cc.renode_id
-   
+
+   //these three ones(base, top, cursor) will be changed after when statement, so below assighnment do not affect
    rs1_c.bounds.base   := cap_uncompress_cap.cap_fat.bounds.base
    rs1_c.bounds.top    := cap_uncompress_cap.cap_fat.bounds.top
-   rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor   
+   rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor     
+  //  rs1_c.bounds.base   := 100230132.U
+  //  rs1_c.bounds.top    := 100230328.U
+  //  rs1_c.bounds.cursor := 100230256.U   
    rs1_c.renode_id     := cap_uncompress_cap.cap_fat.renode_id
    rs1_c.reg_id        := cap_uncompress_cap.cap_fat.reg_id
    rs1_c.async         := cap_uncompress_cap.cap_fat.async
@@ -859,40 +875,28 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty
 
 
-  cursor := rs1_c.bounds.cursor
-  
+  cursor := cap_uncompress_cap.cap_fat.bounds.cursor
+  printf("origin base top cursor: %b , %b , %b \n ",cap_uncompress_cap.cap_fat.bounds.base, cap_uncompress_cap.cap_fat.bounds.top ,cap_uncompress_cap.cap_fat.bounds.cursor )
+  printf("shrinked PARAMETERS: %b , %b , %b , %b , %b\n ",src.cap_c, src.tag_a,src.tag_b ,src.tag_c,rs1_c.meta.ty )
+
   when ((src.tag_a=/=0.U) || (src.tag_b=/=0.U) || (src.tag_c===0.U) ||
      ((rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_LINEAR) && (rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_NONLIN) && (rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_UNINIT)) ||
-     (src.operand_a >= src.operand_b)===1.U || (src.operand_a < rs1_c.bounds.base)===1.U ||
-     (src.operand_b > rs1_c.bounds.top)===1.U) 
+     (src.operand_a >= src.operand_b)===1.U || (src.operand_a < cap_uncompress_cap.cap_fat.bounds.base)===1.U ||
+     (src.operand_b > cap_uncompress_cap.cap_fat.bounds.top)===1.U) 
   {            
     ex_o_v := 1.U
-    // $display("ex valid");
-    // $display("exception: tag_a = %b, tag_b = %b, tag_c = %b, type = %d", fu_data_cur.tag_a, fu_data_cur.tag_b, fu_data_cur.tag_c, rs1_c.meta.ty);
+    printf("shrink exception\n")
+
     //TODO: set tval and cause
   }
-          // if (fu_data_cur.tag_a || fu_data_cur.tag_b || !fu_data_cur.tag_c) begin
-          //     $display("tags ex");
-          // end
-          // if (!(rs1_c.meta.ty inside {capstone::CAP_TYPE_LINEAR, capstone::CAP_TYPE_NONLIN, capstone::CAP_TYPE_UNINIT})) begin
-          //     $display("type ex");
-          // end
-          // if (fu_data_cur.operand_a >= fu_data_cur.operand_b) begin
-          //     $display("bas e >= top");
-          // end
-          // if (fu_data_cur.operand_a < rs1_c.bounds.base) begin
-          //     $display("base < base");
-          // end
-          // if (fu_data_cur.operand_b > rs1_c.bounds.top) begin
-          //     $display("top > top");
-          //     $display("input top = %x, actual top = %x", fu_data_cur.operand_b, rs1_c.bounds.top);
-          // end
-
-          //so, we execute this portion if exception is valid or skip and handle exception in ex_stage?
+
+   //so, we execute this portion if exception is valid or skip and handle exception in ex_stage?
    rs1_c.bounds.base   := src.operand_a
    rs1_c.bounds.top    := src.operand_b
    rs1_c.bounds.cursor := Mux(cursor<src.operand_a, src.operand_a,Mux(cursor>src.operand_b, src.operand_b, cursor))
   
+   printf("shrinked new base top cursor: %b , %b , %b \n ",rs1_c.bounds.base, rs1_c.bounds.top , rs1_c.bounds.cursor )
+
   //  rs1_cc = capstone::cap_compress(rs1_c);
   //  cap_compress_cap.cap_fat:=rs1_c
   //  rs1_cc:= cap_compress_cap.cap_cc
@@ -907,27 +911,130 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    cap_compress_cap.cap_fat.padding     :=rs1_c.padding
 
    
-   rs1_cc.bounds.iE   := cap_compress_cap.cap_cc.bounds.iE
-   rs1_cc.bounds.t    := cap_compress_cap.cap_cc.bounds.t
-   rs1_cc.bounds.tE   := cap_compress_cap.cap_cc.bounds.tE  
-   rs1_cc.bounds.b    := cap_compress_cap.cap_cc.bounds.b  
-   rs1_cc.bounds.bE   := cap_compress_cap.cap_cc.bounds.bE  
-   rs1_cc.renode_id     := cap_compress_cap.cap_cc.renode_id
-   rs1_cc.meta.perm     := cap_compress_cap.cap_cc.meta.perm
-   rs1_cc.meta.ty       := cap_compress_cap.cap_cc.meta.ty
+   rs2_cc.bounds.iE   := cap_compress_cap.cap_cc.bounds.iE
+   rs2_cc.bounds.t    := cap_compress_cap.cap_cc.bounds.t
+   rs2_cc.bounds.tE   := cap_compress_cap.cap_cc.bounds.tE  
+   rs2_cc.bounds.b    := cap_compress_cap.cap_cc.bounds.b  
+   rs2_cc.bounds.bE   := cap_compress_cap.cap_cc.bounds.bE  
+   rs2_cc.renode_id   := cap_compress_cap.cap_cc.renode_id
+   rs2_cc.meta.perm   := cap_compress_cap.cap_cc.meta.perm
+   rs2_cc.meta.ty     := cap_compress_cap.cap_cc.meta.ty
 
 
   // rd_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
 
-    cshrink2.cap  := Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm,rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor )
+    cshrink2.cap  := Cat(rs2_cc.bounds.cursor , rs2_cc.bounds.bE , rs2_cc.bounds.b , rs2_cc.bounds.tE , rs2_cc.bounds.t , rs2_cc.bounds.iE , rs2_cc.meta.perm, rs2_cc.meta.ty , rs2_cc.renode_id)
     cshrink2.tag  := 0.U 
     cshrink2.valid:= 1.U
 
     cshrink.cap        := 0.U
     cshrink.tag        := 0.U 
     cshrink.valid      := 0.U
+}
+
+
+class cshrinktoModule(implicit p: Parameters) extends XSModule {
+ val src        = IO(Input(new fu_data_t))
+ val cshrinkto  = IO(Output(new cap_result_t ))
+ val cshrinkto2 = IO(Output(new cap_result_t )) 
+ val  ex_o_v    = IO(Output (UInt(1.W) ))
+ ex_o_v := 0.U
+
+ //unpacked capability
+ val rs1_cc =Reg(new cap_cc_t)  
+ val rs2_cc =Reg(new cap_cc_t)  
+ val rs1_c  =Reg(new cap_fat_t)
+
+ rs1_cc.renode_id  := src.cap_c(30,0)//31
+ rs1_cc.meta.ty    := src.cap_c(33,31) //6
+ rs1_cc.meta.perm  := src.cap_c(36,34) //6  
+ rs1_cc.bounds.iE  := src.cap_c(37)    //1
+ rs1_cc.bounds.t   := src.cap_c(46,38) //9
+ rs1_cc.bounds.tE  := src.cap_c(49,47) //3
+ rs1_cc.bounds.b   := src.cap_c(60,50) //11
+ rs1_cc.bounds.bE  := src.cap_c(63,61)//3
+ rs1_cc.bounds.cursor  := src.cap_c(127,64)//64
+   
+ val cap_uncompress_cap=Module(new cap_uncompress)
+ val cap_compress_cap  =Module(new cap_compress) 
+ // cap_uncompress_cap.cap_cc:=rs1_cc
+ // rs1_c := cap_uncompress_cap.cap_fat
+  cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
+  cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
+  cap_uncompress_cap.cap_cc.bounds.tE  :=rs1_cc.bounds.tE
+  cap_uncompress_cap.cap_cc.bounds.b   :=rs1_cc.bounds.b
+  cap_uncompress_cap.cap_cc.bounds.bE  :=rs1_cc.bounds.bE   
+  cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
+  cap_uncompress_cap.cap_cc.meta.ty     :=rs1_cc.meta.ty
+  cap_uncompress_cap.cap_cc.meta.perm   :=rs1_cc.meta.perm
+  cap_uncompress_cap.cap_cc.renode_id   :=rs1_cc.renode_id 
+  //these three ones(base, top, cursor) will be changed after when statement, so below assighnment do not affect
+  rs1_c.bounds.base   := cap_uncompress_cap.cap_fat.bounds.base
+  rs1_c.bounds.top    := cap_uncompress_cap.cap_fat.bounds.top
+  rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor//200.U    
+  rs1_c.renode_id     := cap_uncompress_cap.cap_fat.renode_id
+  rs1_c.reg_id        := cap_uncompress_cap.cap_fat.reg_id
+  rs1_c.async         := cap_uncompress_cap.cap_fat.async
+  rs1_c.padding       := cap_uncompress_cap.cap_fat.padding
+  rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
+  rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty
+
+  val k1= cap_uncompress_cap.cap_fat.bounds.base
+  val k2= cap_uncompress_cap.cap_fat.bounds.top
+
+  when ((src.tag_a=/=0.U) || (src.tag_b=/=0.U) || (src.tag_c===0.U) ||
+     ((rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_LINEAR) && (rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_NONLIN) && (rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_UNINIT)) ||
+     (rs1_c.bounds.cursor < k1)===1.U ||
+     ((rs1_c.bounds.cursor +  src.imm(11,0) )> k2)===1.U) 
+  {            
+    ex_o_v := 1.U
+    printf("shrinkto exception\n")
   }
-  class ctightenModule(implicit p: Parameters) extends XSModule {
+
+   //so, we execute this portion if exception is valid or skip and handle exception in ex_stage?
+   rs1_c.bounds.base   := rs1_c.bounds.cursor
+   rs1_c.bounds.top    := rs1_c.bounds.cursor + src.imm(11,0)
+  
+   printf("shrinkto new base top cursor: %b , %b , %b , %b \n ",rs1_c.bounds.base, rs1_c.bounds.top , rs1_c.bounds.cursor, src.imm(11,0) )
+
+  //  rs1_cc = capstone::cap_compress(rs1_c);
+  //  cap_compress_cap.cap_fat:=rs1_c
+  //  rs1_cc:= cap_compress_cap.cap_cc
+   cap_compress_cap.cap_fat.bounds.base  :=rs1_c.bounds.base
+   cap_compress_cap.cap_fat.bounds.top   :=rs1_c.bounds.top  
+   cap_compress_cap.cap_fat.bounds.cursor:=rs1_c.bounds.cursor
+   cap_compress_cap.cap_fat.meta.ty     :=rs1_c.meta.ty
+   cap_compress_cap.cap_fat.meta.perm   :=rs1_c.meta.perm
+   cap_compress_cap.cap_fat.renode_id   :=rs1_c.renode_id
+   cap_compress_cap.cap_fat.reg_id      :=rs1_c.reg_id
+   cap_compress_cap.cap_fat.async       :=rs1_c.async
+   cap_compress_cap.cap_fat.padding     :=rs1_c.padding
+
+   
+   rs2_cc.bounds.iE   := cap_compress_cap.cap_cc.bounds.iE
+   rs2_cc.bounds.t    := cap_compress_cap.cap_cc.bounds.t
+   rs2_cc.bounds.tE   := cap_compress_cap.cap_cc.bounds.tE  
+   rs2_cc.bounds.b    := cap_compress_cap.cap_cc.bounds.b  
+   rs2_cc.bounds.bE   := cap_compress_cap.cap_cc.bounds.bE  
+   rs2_cc.renode_id   := cap_compress_cap.cap_cc.renode_id
+   rs2_cc.meta.perm   := cap_compress_cap.cap_cc.meta.perm
+   rs2_cc.meta.ty     := cap_compress_cap.cap_cc.meta.ty
+
+
+  // rd_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
+
+    cshrinkto2.cap  := Cat(rs2_cc.bounds.cursor , rs2_cc.bounds.bE , rs2_cc.bounds.b , rs2_cc.bounds.tE , rs2_cc.bounds.t , rs2_cc.bounds.iE , rs2_cc.meta.perm, rs2_cc.meta.ty , rs2_cc.renode_id)
+    cshrinkto2.tag  := 0.U 
+    cshrinkto2.valid:= 1.U
+
+    cshrinkto.cap  := 0.U
+    cshrinkto.tag  := 0.U(1.W)
+    cshrinkto.valid:= 0.U(1.W)  
+
+}
+
+
+class ctightenModule(implicit p: Parameters) extends XSModule {
    val src          = IO(Input(new fu_data_t))
    val ctighten     = IO(Output(new cap_result_t ))   
    val ctighten2    = IO(Output(new cap_result_t ))
@@ -935,13 +1042,11 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
 
    ex_o_v:=0.U
 
-   val cursor= 0.U(XLEN.W)
-
-   val rs1_cc=Wire(new cap_cc_t)  
-   val res   =Wire(new cap_cc_t)  
-   val imm = src.operand_b
+   val rs1_cc = Wire(new cap_cc_t)  
+   val res    = Wire(new cap_cc_t)  
+   val imm    = src.operand_b(4,0)//5bit
 
-   rs1_cc.renode_id := src.cap_a(30,0)//31
+   rs1_cc.renode_id  := src.cap_a(30,0)//31
    rs1_cc.meta.ty    := src.cap_a(33,31) //6
    rs1_cc.meta.perm  := src.cap_a(36,34) //6  
    rs1_cc.bounds.iE  := src.cap_a(37)    //1
@@ -950,17 +1055,21 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    rs1_cc.bounds.b   := src.cap_a(60,50) //11
    rs1_cc.bounds.bE  := src.cap_a(63,61)//3
    rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
+        
+   printf("tighten parameter imm, perm =%b ,%b  \n",imm, rs1_cc.meta.perm)
 
-   when (src.tag_a===0.U || (rs1_cc.meta.ty=/=cap_type_t.CAP_TYPE_LINEAR || rs1_cc.meta.ty===cap_type_t.CAP_TYPE_NONLIN || rs1_cc.meta.ty===cap_type_t.CAP_TYPE_UNINIT) ||
-      (rs1_cc.meta.perm =/=(imm))) 
+   when (src.tag_a===0.U || (rs1_cc.meta.ty=/=cap_type_t.CAP_TYPE_LINEAR && rs1_cc.meta.ty=/=cap_type_t.CAP_TYPE_NONLIN && rs1_cc.meta.ty=/=cap_type_t.CAP_TYPE_UNINIT)
+   ||(((rs1_cc.meta.perm >imm)===1.U)&&((8.U >imm)===1.U)))
     {
-        //this casting could fail
+        printf("tighten exception\n")
         ex_o_v := 1.U
     }
 
     res:= rs1_cc
+    // res<> rs1_cc
     res.meta.perm := Mux (imm > 7.U(3.W) , 0.U(3.W) , imm )
-          
+    printf("tighten new perm %b:\n",res.meta.perm)
+        
     when (src.rs1 === src.rd) 
     {
       ctighten.cap  := 0.U
@@ -968,22 +1077,26 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
       ctighten.valid:= 0.U(1.W)
 
     // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1};
-      ctighten2.cap  := Cat(res.renode_id,res.meta.ty,res.meta.perm,res.bounds.iE , res.bounds.t , res.bounds.tE , res.bounds.b , res.bounds.bE ,res.bounds.cursor)
+      ctighten2.cap  := Cat(res.bounds.cursor , res.bounds.bE , res.bounds.b , res.bounds.tE , res.bounds.t , res.bounds.iE , res.meta.perm, res.meta.ty , res.renode_id)
       ctighten2.tag  := 1.U(1.W)
-      ctighten2.valid:= 1.U(1.W)  
+      ctighten2.valid:= 1.U(1.W) 
+      printf("tighten rs1==rd\n")
+ 
     }
     .elsewhen (rs1_cc.meta.ty === cap_type_t.CAP_TYPE_NONLIN)
     {
     // rs1_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
     // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1}; 
 
-      ctighten.cap  := Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm,rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor )
+      ctighten.cap  := Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.bE , rs1_cc.bounds.b , rs1_cc.bounds.tE , rs1_cc.bounds.t , rs1_cc.bounds.iE , rs1_cc.meta.perm, rs1_cc.meta.ty , rs1_cc.renode_id )
       ctighten.tag  := 1.U(1.W)
       ctighten.valid:= 1.U(1.W)
 
-      ctighten2.cap  := Cat(res.renode_id,res.meta.ty,res.meta.perm,res.bounds.iE , res.bounds.t , res.bounds.tE , res.bounds.b , res.bounds.bE ,res.bounds.cursor )
+      ctighten2.cap  := Cat(res.bounds.cursor , res.bounds.bE , res.bounds.b , res.bounds.tE , res.bounds.t , res.bounds.iE , res.meta.perm, res.meta.ty , res.renode_id)
       ctighten2.tag  := 1.U(1.W)
-      ctighten2.valid:= 1.U(1.W)            
+      ctighten2.valid:= 1.U(1.W) 
+      printf("tighten CAP_TYPE_NONLIN\n")
+
     }
     .otherwise 
     { // rs1 is a linear type
@@ -993,13 +1106,14 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
       ctighten.tag  := 0.U(1.W)
       ctighten.valid:= 1.U(1.W) 
 
-      ctighten2.cap   := Cat(res.renode_id,res.meta.ty,res.meta.perm,res.bounds.iE , res.bounds.t , res.bounds.tE , res.bounds.b , res.bounds.bE ,res.bounds.cursor )
+      ctighten2.cap   := Cat(res.bounds.cursor , res.bounds.b,res.bounds.bE,res.bounds.tE,res.bounds.t,res.bounds.iE,res.meta.perm,res.meta.ty,res.renode_id)
       ctighten2.tag         := 1.U(1.W)
       ctighten2.valid       := 1.U(1.W) 
 
      }
-  }
- class cdelinModule extends Module {
+
+}
+class cdelinModule extends Module {
   val src     = IO(Input(new fu_data_t))
   val cdelin  = IO(Output(new cap_result_t ))   
   val cdelin2 = IO(Output(new cap_result_t ))   
@@ -1011,40 +1125,45 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    //unpacked capability
    val rs1_cc=Wire(new cap_cc_t)  
    val send_node_mut_ins    =IO(new send_node_mut_bundle())
-   val send_node_mut_c      = Module(new send_node_mut)
+   val send_node_mut_c      =Module(new send_node_mut)
    send_node_mut_ins<>send_node_mut_c.ins
-
-
-   rs1_cc.renode_id := Cat(src.cap_c(30,0))//31
-   rs1_cc.meta.ty    := Cat(src.cap_c(36,31)) //6
-   rs1_cc.meta.perm  := Cat(src.cap_c(36,34)) //6  
-   rs1_cc.bounds.iE  := Cat(src.cap_c(37))    //1
-   rs1_cc.bounds.t   := Cat(src.cap_c(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_c(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_c(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_c(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_c(127,64)) //64
-
-
-   when (src.tag_c===0.U || (rs1_cc.meta.ty =/= cap_type_t.CAP_TYPE_LINEAR)) 
+   
+   val k = src.cap_c(36,31)
+
+   rs1_cc.renode_id  := (src.cap_c(30,0))//31
+   rs1_cc.meta.ty    := (src.cap_c(36,31)) //6
+   rs1_cc.meta.perm  := (src.cap_c(36,34)) //6  
+   rs1_cc.bounds.iE  := (src.cap_c(37))    //1
+   rs1_cc.bounds.t   := (src.cap_c(46,38)) //9
+   rs1_cc.bounds.tE  := (src.cap_c(49,47)) //3
+   rs1_cc.bounds.b   := (src.cap_c(60,50)) //11
+   rs1_cc.bounds.bE  := (src.cap_c(63,61))//3
+   rs1_cc.bounds.cursor  := (src.cap_c(127,64)) //64
+
+   printf( "befor delin type is: %b\n",k )
+
+  //  when (src.tag_c===0.U || (rs1_cc.meta.ty =/= cap_type_t.CAP_TYPE_LINEAR)) 
+   when (src.tag_c===0.U || (k =/= cap_type_t.CAP_TYPE_LINEAR)) 
    {
     ex_o_v := 1.U
+    printf("delin exception\n")
+
    }
-   printf( "delin ex_o_v %b\n",ex_o_v)
 
    rs1_cc.meta.ty := cap_type_t.CAP_TYPE_NONLIN
-   printf( "delin is done right typeis: %b\n",rs1_cc.meta.ty)
+   printf( "delin is done right. type is: %b\n",rs1_cc.meta.ty)
 
-    cdelin2.cap  := Cat(rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)
-    cdelin2.tag  := 1.U(1.W)
-    cdelin2.valid:= 1.U(1.W)   
+   cdelin2.cap  := Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
+   cdelin2.tag  := 1.U(1.W)
+   cdelin2.valid:= 1.U(1.W)   
 
    cdelin.cap  := 0.U 
    cdelin.tag  := 0.U(1.W)
    cdelin.valid:= 0.U(1.W)  
+   printf( "befor delin cdelin2.cap: %b\n",cdelin2.cap )
 
-  ////send_node_mut(rs1_cc.renode_id, NODE_DELIN);
-  //node port
+    ////send_node_mut(rs1_cc.renode_id, NODE_DELIN);
+    //node port
     send_node_mut_c.ins.revnode_id:=rs1_cc.renode_id
     send_node_mut_c.ins.mut_ty:=node_mut_type_t.NODE_DELIN
     //initial
@@ -1053,12 +1172,12 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
 
     printf( "delin send_node_mut_c.ins.mut_ty %b\n",send_node_mut_c.ins.mut_ty)
 
-  }
- class clccModule extends Module {
+}
+class clccModule extends Module {
 
-    val src = IO(Input(new fu_data_t))
-    val clcc = IO(Output(new cap_result_t ))   
-    val clcc2 = IO(Output(new cap_result_t )) 
+    val src    = IO(Input(new fu_data_t))
+    val clcc   = IO(Output(new cap_result_t ))   
+    val clcc2  = IO(Output(new cap_result_t )) 
     val  ex_o_v= IO(Output (UInt(1.W) ))
     
     ex_o_v:=0.U
@@ -1067,8 +1186,8 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    //unpacked capability
    val rs1_cc=Wire(new cap_cc_t)  
    val rs1_c =Wire(new cap_fat_t)
-   val imm   = Wire(UInt(XLEN.W))
-   val ty    = Wire(UInt(XLEN.W))
+   val imm   = Wire(UInt(3.W))//Wire(UInt(XLEN.W))
+   val ty    = Wire(UInt(3.W))//Wire(UInt(XLEN.W))
    val res   = Wire(UInt(XLEN.W))
 
    val cap_uncompress_cap=Module(new cap_uncompress)
@@ -1082,15 +1201,15 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
 
 
 
-   rs1_cc.renode_id := Cat(src.cap_a(30,0))//31
-   rs1_cc.meta.ty   := Cat(src.cap_a(33,31)) //6
-   rs1_cc.meta.perm := Cat(src.cap_a(36,34)) //6
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37))    //1
-   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   rs1_cc.renode_id  := src.cap_a(30,0)//31
+   rs1_cc.meta.ty    := src.cap_a(33,31) //6
+   rs1_cc.meta.perm  := src.cap_a(36,34) //6
+   rs1_cc.bounds.iE  := src.cap_a(37)   //1
+   rs1_cc.bounds.t   := src.cap_a(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+   rs1_cc.bounds.b   := src.cap_a(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
 
   //  cap_uncompress_cap.cap_cc:=rs1_cc
   //  rs1_c := cap_uncompress_cap.cap_fat
@@ -1115,15 +1234,18 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
    rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty 
 
-   imm   := src.operand_b
+   imm   := src.operand_b(2,0)
    ty    := (rs1_c.meta.ty)
          
-   if (src.tag_a==0.U || (imm == 2.U(3.W) && ty == 4.U(3.W)) || ((imm == 4.U(3.W) || imm == 5.U(3.W)) && (ty==4.U(3.W) || ty==5.U(3.W) || ty==6.U(3.W))) ||
-      (imm == 6.U(3.W) && (ty!=4.U(3.W) && ty!=5.U(3.W))) || (imm == 7.U(3.W) && (ty != 5.U(3.W)))) 
+   when (src.tag_a===0.U || (imm ===2.U(3.W) && ty === 4.U(3.W)) || ((imm === 4.U(3.W) || imm === 5.U(3.W)) && (ty===4.U(3.W) || ty===5.U(3.W) || ty===6.U(3.W))) ||
+      (imm === 6.U(3.W) && (ty=/=4.U(3.W) && ty=/=5.U(3.W))) || (imm === 7.U(3.W) && (ty =/= 5.U(3.W)))) 
       {
        ex_o_v := 1.U
+       printf("clcc exception\n")
+
       }
-    
+    printf("imm ,in clcc is : %b\n", imm )
+
     res :=0.U(XLEN.W)
     switch (imm)
     {
@@ -1134,30 +1256,43 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
       is (1.U)
       { 
         res:= rs1_c.meta.ty
+        printf("clcc convert type\n")
       }
       is(2.U)
       {
         res := rs1_c.bounds.cursor
+        printf("clcc convert cursor\n")
+
       }
       is (3.U)
       {
         res := rs1_c.bounds.base
+        printf("clcc convert base\n")
+
       }
       is (4.U)
       {  
         res:= rs1_c.bounds.top
+        printf("clcc convert top\n")
+
       }
       is (5.U)
       {
         res:= rs1_c.meta.perm
+        printf("clcc convert perm\n")
+
       }
       is (6.U)
       {
        res := rs1_c.async
+       printf("clcc convert async\n")
+
       }
       is (7.U) 
       {
         res := rs1_c.reg_id
+        printf("clcc convert reg_id\n")
+
       }
     }
 
@@ -1169,23 +1304,23 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
     clcc.tag:= 0.U(1.W)
     clcc.valid:= 1.U(1.W) 
 
-     if (imm == 0.U) 
+    when (imm === 0.U) 
     {
     // send_node_query(rs1_c.renode_id, 1'b1);
       send_node_query_c.ins.revnode_id:=rs1_c.renode_id
       send_node_query_c.ins.synchronous:=1.U
       //initial
-      send_node_query_c.ins.node_query_sent_q          := 0.U
-      send_node_query_c.ins.node_query_ready_i         := 0.U
-      send_node_query_c.ins.node_query_resp_valid_i    := 0.U
-      send_node_query_c.ins.node_query_resp_received_q := 0.U 
-      send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
-      send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
-      send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U 
+      // send_node_query_c.ins.node_query_sent_q          := 0.U
+      // send_node_query_c.ins.node_query_ready_i         := 0.U
+      // send_node_query_c.ins.node_query_resp_valid_i    := 0.U
+      // send_node_query_c.ins.node_query_resp_received_q := 0.U 
+      // send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
+      // send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
+      // send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U 
      }
-  }
+}
 
- class csccModule extends Module {
+class csccModule extends Module {
    val src   = IO(Input(new fu_data_t))
    val cscc  = IO(Output(new cap_result_t ))   
    val cscc2 = IO(Output(new cap_result_t ))
@@ -1198,15 +1333,15 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    val res   =Wire(new cap_cc_t)
    val rs1_c =Wire(new cap_fat_t)
 
-   rs1_cc.renode_id := src.cap_a(30,0)//31
-   rs1_cc.meta.ty   := src.cap_a(33,31) //6
-   rs1_cc.meta.perm := src.cap_a(36,34) //6
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37))    //1
-   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   rs1_cc.renode_id  := src.cap_a(30,0)//31
+   rs1_cc.meta.ty    := src.cap_a(33,31) //6
+   rs1_cc.meta.perm  := src.cap_a(36,34) //6
+   rs1_cc.bounds.iE  := src.cap_a(37)    //1
+   rs1_cc.bounds.t   := src.cap_a(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+   rs1_cc.bounds.b   := src.cap_a(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
    
   val cap_uncompress_cap = Module(new cap_uncompress)
   val cap_compress_cap   = Module(new cap_compress)
@@ -1234,12 +1369,14 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
    rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
    rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty 
  
-  if(src.tag_a==0.U || src.tag_b!=0.U || (rs1_c.meta.ty==cap_type_t.CAP_TYPE_UNINIT) || (rs1_c.meta.ty==cap_type_t.CAP_TYPE_SEALED)) 
+  when(src.tag_a===0.U || src.tag_b=/=0.U || (rs1_c.meta.ty===cap_type_t.CAP_TYPE_UNINIT) || (rs1_c.meta.ty===cap_type_t.CAP_TYPE_SEALED)) 
    {    
     ex_o_v := 1.U
+    printf("SCC exception\n")
    }
 
    rs1_c.bounds.cursor := src.operand_b
+   printf("SCC convert the cursor to %b:\n",src.operand_b )
 
   //  cap_compress_cap.cap_fat:=rs1_c
   //  res:= cap_compress_cap.cap_cc
@@ -1256,7 +1393,7 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
 
   res.bounds.iE := cap_compress_cap.cap_cc.bounds.iE
   res.bounds.t  := cap_compress_cap.cap_cc.bounds.t
-  res.bounds.tE :=cap_compress_cap.cap_cc.bounds.tE
+  res.bounds.tE := cap_compress_cap.cap_cc.bounds.tE
   res.bounds.b  := cap_compress_cap.cap_cc.bounds.b
   res.bounds.bE := cap_compress_cap.cap_cc.bounds.bE   
   res.bounds.cursor := cap_compress_cap.cap_cc.bounds.cursor
@@ -1264,34 +1401,32 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
   res.meta.perm := cap_compress_cap.cap_cc.meta.perm
   res.renode_id :=  cap_compress_cap.cap_cc.renode_id
 
-   if (src.rs1 == src.rd) 
+   when (src.rs1 === src.rd) 
    {
-    // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1};
-    cscc2.cap(30,30):= res.renode_id
-    cscc2.cap(33,31):= res.meta.ty
-    cscc2.cap(36,34):= res.meta.perm
-    cscc2.cap(127,37):= Cat(res.bounds.iE,res.bounds.t,res.bounds.tE,res.bounds.b,res.bounds.bE,res.bounds.cursor )
-    cscc2.tag:= 1.U(1.W)
+
+    cscc.cap  := 0.U
+    cscc.tag  := 0.U(1.W)
+    cscc.valid:= 0.U(1.W)
+
+    cscc2.cap  :=Cat(res.bounds.cursor , res.bounds.b,res.bounds.bE,res.bounds.tE,res.bounds.t,res.bounds.iE,res.meta.perm,res.meta.ty,res.renode_id)
+    cscc2.tag  := 1.U(1.W)
     cscc2.valid:= 1.U(1.W)
    } 
-   else if (rs1_cc.meta.ty == cap_type_t.CAP_TYPE_NONLIN)
+    .elsewhen (rs1_cc.meta.ty === cap_type_t.CAP_TYPE_NONLIN)
    {
-      // rs1_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
-      // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1};  
-    cscc.cap  := Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)
+
+    cscc.cap  :=Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
     cscc.tag  := 1.U(1.W)
     cscc.valid:= 1.U(1.W)
 
-    cscc2.cap  := Cat(res.renode_id,res.meta.ty,res.meta.perm, res.renode_id, res.meta.ty , res.meta.perm, res.bounds.iE , res.bounds.t , res.bounds.tE , res.bounds.b , res.bounds.bE ,res.bounds.cursor)
+    cscc2.cap  := Cat(res.bounds.cursor , res.bounds.b,res.bounds.bE,res.bounds.tE,res.bounds.t,res.bounds.iE,res.meta.perm,res.meta.ty,res.renode_id)
     cscc2.tag  := 1.U(1.W)
     cscc2.valid:= 1.U(1.W)    
     
     
     } 
-    else
+    .otherwise 
     { // rs1 is a linear type
-      // rs1_result_o = '{cap: '0, tag: '0, valid: '1};
-      // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1};
     cscc.cap       := 0.U(128.W)
     cscc.tag       := 0.U(1.W)
     cscc.valid     := 1.U(1.W)
@@ -1300,131 +1435,134 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
     cscc2.tag:= 1.U(1.W)
     cscc2.valid:= 1.U(1.W)      
     }
-  }
+}
 
- class csplitModule extends Module {
+class csplitModule extends Module {
  
-   val src      = IO(Input(new fu_data_t))
-   val csplit   = IO(Output(new cap_result_t ))  
-   val csplit2  = IO(Output(new cap_result_t ))
-   val  ex_o_v  = IO(Output (UInt(1.W) ))
+ val src      = IO(Input(new fu_data_t))
+ val csplit   = IO(Output(new cap_result_t ))  
+ val csplit2  = IO(Output(new cap_result_t ))
+ val  ex_o_v  = IO(Output (UInt(1.W) )) 
+ ex_o_v:=0.U 
+ val send_node_query_ins  =IO(new send_node_query_bundle())
+ val send_node_mut_ins    =IO(new send_node_mut_bundle())
+ val send_node_alloc_ins  =IO(new send_node_alloc_bundle()) 
+ val send_node_query_c    = Module(new send_node_query)
+ val send_node_mut_c      = Module(new send_node_mut)
+ val send_node_alloc_c    = Module(new send_node_alloc) 
+ send_node_query_ins<>send_node_query_c.ins
+ send_node_mut_ins<>send_node_mut_c.ins
+ send_node_alloc_ins<>send_node_alloc_c.ins 
+ //unpacked capability
+ val rs1_cc=Reg(new cap_cc_t)
+ val rs2_cc=Reg(new cap_cc_t)
+ val rd_cc =Reg(new cap_cc_t)
+ val rs1_c =Reg(new cap_fat_t)
+ val rd_c  =Reg(new cap_fat_t)
+ 
+ val rs2 = Reg(UInt (XLEN.W))
+ rs2:=src.operand_b 
+ rs1_cc.renode_id  := src.cap_a(30,0)//31
+ rs1_cc.meta.ty    := src.cap_a(33,31) //6
+ rs1_cc.meta.perm  := src.cap_a(36,34) //6
+ rs1_cc.bounds.iE  := src.cap_a(37)    //1
+ rs1_cc.bounds.t   := src.cap_a(46,38) //9
+ rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+ rs1_cc.bounds.b   := src.cap_a(60,50) //11
+ rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+ rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
+ 
+ val cap_uncompress_cap=Module(new cap_uncompress)
+ val cap_compress_cap  =Module(new cap_compress) 
+ // cap_uncompress_cap.cap_cc:=rs1_cc
+ // rs1_c := cap_uncompress_cap.cap_fat
+ cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
+ cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
+ cap_uncompress_cap.cap_cc.bounds.tE  :=rs1_cc.bounds.tE
+ cap_uncompress_cap.cap_cc.bounds.b   :=rs1_cc.bounds.b
+ cap_uncompress_cap.cap_cc.bounds.bE  :=rs1_cc.bounds.bE   
+ cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
+ cap_uncompress_cap.cap_cc.meta.ty     :=rs1_cc.meta.ty
+ cap_uncompress_cap.cap_cc.meta.perm   :=rs1_cc.meta.perm
+ cap_uncompress_cap.cap_cc.renode_id   :=rs1_cc.renode_id
+ 
+ rs1_c.bounds.base   := cap_uncompress_cap.cap_fat.bounds.base
+ rs1_c.bounds.top    := cap_uncompress_cap.cap_fat.bounds.top
+ rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor   
+ rs1_c.renode_id     := cap_uncompress_cap.cap_fat.renode_id
+ rs1_c.reg_id        := cap_uncompress_cap.cap_fat.reg_id
+ rs1_c.async         := cap_uncompress_cap.cap_fat.async
+ rs1_c.padding       := cap_uncompress_cap.cap_fat.padding
+ rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
+ rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty 
+
+ val k = cap_uncompress_cap.cap_fat.bounds.top
+ 
+  // rd_c  := rs1_c
+  // rd_c  <> rs1_c
+ rd_c.bounds.base   := rs1_c.bounds.base   
+ rd_c.bounds.top    := k//rs1_c.bounds.top    
+ rd_c.bounds.cursor := rs1_c.bounds.cursor 
+ rd_c.renode_id     := rs1_c.renode_id     
+ rd_c.reg_id        := rs1_c.reg_id        
+ rd_c.async         := rs1_c.async         
+ rd_c.padding       := rs1_c.padding       
+ rd_c.meta.perm     := rs1_c.meta.perm     
+ rd_c.meta.ty       := rs1_c.meta.ty       
 
-   ex_o_v:=0.U
+  // printf("split rd_c %b\n", rd_c.bounds.base)
 
-   val send_node_query_ins  =IO(new send_node_query_bundle())
-   val send_node_mut_ins    =IO(new send_node_mut_bundle())
-   val send_node_alloc_ins  =IO(new send_node_alloc_bundle())
+  // printf("split rs1_c %b\n",rs1_c.bounds.base)
 
-   val send_node_query_c    = Module(new send_node_query)
-   val send_node_mut_c      = Module(new send_node_mut)
-   val send_node_alloc_c    = Module(new send_node_alloc)
 
-   send_node_query_ins<>send_node_query_c.ins
-   send_node_mut_ins<>send_node_mut_c.ins
-   send_node_alloc_ins<>send_node_alloc_c.ins
+  //validity check
+  when ((src.tag_a===0.U) || (src.tag_b===1.U) || ((rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_LINEAR) && (rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_NONLIN))) 
+  {
+    ex_o_v := 1.U
+    printf( "split ex_o %b\n",ex_o_v)
 
-   //unpacked capability
-   val rs1_cc=Reg(new cap_cc_t)
-   val rd_cc =Reg(new cap_cc_t)
-   val rs1_c =Reg(new cap_fat_t)
-   val rd_c  =Reg(new cap_fat_t)
-   
-   val rs2 = Reg(UInt (XLEN.W))
-   rs2:=src.operand_b
+  }
 
-   rs1_cc.renode_id  := Cat(src.cap_a(30,0))//31
-   rs1_cc.meta.ty    := Cat(src.cap_a(33,31)) //6
-   rs1_cc.meta.perm  := Cat(src.cap_a(36,34)) //6
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37))    //1
-   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
-   
-  val cap_uncompress_cap=Module(new cap_uncompress)
-  val cap_compress_cap  =Module(new cap_compress)
-
-  // cap_uncompress_cap.cap_cc:=rs1_cc
-  // rs1_c := cap_uncompress_cap.cap_fat
-   cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
-   cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
-   cap_uncompress_cap.cap_cc.bounds.tE  :=rs1_cc.bounds.tE
-   cap_uncompress_cap.cap_cc.bounds.b   :=rs1_cc.bounds.b
-   cap_uncompress_cap.cap_cc.bounds.bE  :=rs1_cc.bounds.bE   
-   cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
-   cap_uncompress_cap.cap_cc.meta.ty     :=rs1_cc.meta.ty
-   cap_uncompress_cap.cap_cc.meta.perm   :=rs1_cc.meta.perm
-   cap_uncompress_cap.cap_cc.renode_id   :=rs1_cc.renode_id
-   
-   rs1_c.bounds.base   := cap_uncompress_cap.cap_fat.bounds.base
-   rs1_c.bounds.top    := cap_uncompress_cap.cap_fat.bounds.top
-   rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor   
-   rs1_c.renode_id     := cap_uncompress_cap.cap_fat.renode_id
-   rs1_c.reg_id        := cap_uncompress_cap.cap_fat.reg_id
-   rs1_c.async         := cap_uncompress_cap.cap_fat.async
-   rs1_c.padding       := cap_uncompress_cap.cap_fat.padding
-   rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
-   rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty 
- 
-
-  rd_c  := rs1_c
-  // rd_c  <> rs1_c
-  printf("split rd_c %b\n", rd_c.bounds.base)
-
-  printf("split rs1_c %b\n",rs1_c.bounds.base)
-
-
-  //validity check
-  // if ((src.tag_a==0.U) || (src.tag_b!=0.U) || !((rs1_c.meta.ty==cap_type_t.CAP_TYPE_LINEAR) && (rs1_c.meta.ty==cap_type_t.CAP_TYPE_NONLIN))) 
-  when ((src.tag_a===0.U) || (src.tag_b===1.U) || ((rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_LINEAR) && (rs1_c.meta.ty=/=cap_type_t.CAP_TYPE_NONLIN))) 
-  {
-    ex_o_v := 1.U
-  }
-
-
-  
- // if ((rs2 <= rs1_c.bounds.base) || (rs2 >= rs1_c.bounds.top)) 
-  // if (( fu_data_cur.operand_b <= rs1_c.bounds.base) || ( fu_data_cur.operand_b >= rs1_c.bounds.top)) 
-  // if ((( rs2 <= rs1_c.bounds.base)==1.U) || (( rs2 >= rs1_c.bounds.top)==1.U)) 
-  when ((( rs2 <= rs1_c.bounds.base)===1.U) || (( rs2 >= rs1_c.bounds.top)===1.U)) 
+  // if ((rs2 <= rs1_c.bounds.base) || (rs2 >= rs1_c.bounds.top)) 
+  // when ((( rs2 <= rs1_c.bounds.base)===1.U) || (( rs2 >= rs1_c.bounds.top)===1.U)) 
+  when ((( rs2 <= rs1_c.bounds.base)===1.U) || (( rs2 >= k)===1.U)) 
   {
-    ex_o_v := 1.U
+   ex_o_v := 1.U
+   printf( "split ex_o %b\n",ex_o_v)
 
   }
-  printf( "split ex_o %b\n",ex_o_v)
-
-// if RS1 == RD, insn is a nop: need to handle this case separately
-// rs1_c.bounds.top    := rs2
-// rs1_c.bounds.cursor := rs1_c.bounds.base
-// rd_c.bounds.base    := rs2
-// rd_c.bounds.cursor  := rs2
-
-// cap_compress_cap.cap_fat:=rs1_c
-// rs1_cc:= cap_compress_cap.cap_cc
-  cap_compress_cap.cap_fat.bounds.base   := rs1_c.bounds.base   
-  cap_compress_cap.cap_fat.bounds.top    := rs1_c.bounds.top     
-  cap_compress_cap.cap_fat.bounds.cursor := rs1_c.bounds.cursor     
-  cap_compress_cap.cap_fat.renode_id     := rs1_c.renode_id      
-  cap_compress_cap.cap_fat.reg_id        :=rs1_c.reg_id         
-  cap_compress_cap.cap_fat.async         := rs1_c.async         
-  cap_compress_cap.cap_fat.padding       := rs1_c.padding
-  cap_compress_cap.cap_fat.meta.perm     := rs1_c.meta.perm 
-  cap_compress_cap.cap_fat.meta.ty       := rs1_c.meta.ty 
 
-  rs1_cc.bounds.iE := cap_compress_cap.cap_cc.bounds.iE
-  rs1_cc.bounds.t  := cap_compress_cap.cap_cc.bounds.t
-  rs1_cc.bounds.tE := cap_compress_cap.cap_cc.bounds.tE
-  rs1_cc.bounds.b  := cap_compress_cap.cap_cc.bounds.b
-  rs1_cc.bounds.bE := cap_compress_cap.cap_cc.bounds.bE   
-  rs1_cc.bounds.cursor := cap_compress_cap.cap_cc.bounds.cursor
-  rs1_cc.meta.ty   := cap_compress_cap.cap_cc.meta.ty
-  rs1_cc.meta.perm := cap_compress_cap.cap_cc.meta.perm
-  rs1_cc.renode_id := cap_compress_cap.cap_cc.renode_id
-
-
-// cap_compress_cap.cap_fat:=rd_c
-// rd_cc:= cap_compress_cap.cap_cc
+  // if RS1 == RD, insn is a nop: need to handle this case separately
+  rs1_c.bounds.top    := rs2
+  rs1_c.bounds.cursor := rs1_c.bounds.base
+  rd_c.bounds.base    := rs2
+  rd_c.bounds.cursor  := rs2
+  printf( "split , new bound for two cap top,base: %b,%b,%b,%b\n",rs1_c.bounds.top,rs1_c.bounds.base,rd_c.bounds.top ,rd_c.bounds.base)
+ 
+ // cap_compress_cap.cap_fat:=rs1_c
+ // rs1_cc:= cap_compress_cap.cap_cc
+ cap_compress_cap.cap_fat.bounds.base   := rs1_c.bounds.base   
+ cap_compress_cap.cap_fat.bounds.top    := rs1_c.bounds.top     
+ cap_compress_cap.cap_fat.bounds.cursor := rs1_c.bounds.cursor     
+ cap_compress_cap.cap_fat.renode_id     := rs1_c.renode_id      
+ cap_compress_cap.cap_fat.reg_id        := rs1_c.reg_id         
+ cap_compress_cap.cap_fat.async         := rs1_c.async         
+ cap_compress_cap.cap_fat.padding       := rs1_c.padding
+ cap_compress_cap.cap_fat.meta.perm     := rs1_c.meta.perm 
+ cap_compress_cap.cap_fat.meta.ty       := rs1_c.meta.ty 
+ rs2_cc.bounds.iE := cap_compress_cap.cap_cc.bounds.iE
+ rs2_cc.bounds.t  := cap_compress_cap.cap_cc.bounds.t
+ rs2_cc.bounds.tE := cap_compress_cap.cap_cc.bounds.tE
+ rs2_cc.bounds.b  := cap_compress_cap.cap_cc.bounds.b
+ rs2_cc.bounds.bE := cap_compress_cap.cap_cc.bounds.bE   
+ rs2_cc.bounds.cursor := cap_compress_cap.cap_cc.bounds.cursor
+ rs2_cc.meta.ty   := cap_compress_cap.cap_cc.meta.ty
+ rs2_cc.meta.perm := cap_compress_cap.cap_cc.meta.perm
+ rs2_cc.renode_id := cap_compress_cap.cap_cc.renode_id
+ 
+ 
+  // cap_compress_cap.cap_fat:=rd_c
+  // rd_cc:= cap_compress_cap.cap_cc
   cap_compress_cap.cap_fat.bounds.base:= rd_c.bounds.base   
   cap_compress_cap.cap_fat.bounds.top := rd_c.bounds.top     
   cap_compress_cap.cap_fat.bounds.cursor := rd_c.bounds.cursor     
@@ -1434,7 +1572,7 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
   cap_compress_cap.cap_fat.padding    := rd_c.padding
   cap_compress_cap.cap_fat.meta.perm  := rd_c.meta.perm 
   cap_compress_cap.cap_fat.meta.ty    := rd_c.meta.ty 
-
+ 
   rd_cc.bounds.iE := cap_compress_cap.cap_cc.bounds.iE
   rd_cc.bounds.t  := cap_compress_cap.cap_cc.bounds.t
   rd_cc.bounds.tE :=cap_compress_cap.cap_cc.bounds.tE
@@ -1444,39 +1582,42 @@ class crevokeModule(implicit p: Parameters) extends XSModule {
   rd_cc.meta.ty   := cap_compress_cap.cap_cc.meta.ty
   rd_cc.meta.perm := cap_compress_cap.cap_cc.meta.perm
   rd_cc.renode_id :=  cap_compress_cap.cap_cc.renode_id
+ 
+ 
+ // rs1_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
+ // rd_result_o = '{cap: 128'(rd_cc), tag: '1, valid: '1};
+ 
+ csplit.cap:= Cat(rs2_cc.bounds.cursor , rs2_cc.bounds.b,rs2_cc.bounds.bE,rs2_cc.bounds.tE,rs2_cc.bounds.t,rs2_cc.bounds.iE,rs2_cc.meta.perm,rs2_cc.meta.ty,rs2_cc.renode_id)
+ csplit.tag:= 1.U(1.W)
+ csplit.valid:= 1.U(1.W)
+ 
+ csplit2.cap  := Cat(rd_cc.bounds.cursor , rd_cc.bounds.b,rd_cc.bounds.bE,rd_cc.bounds.tE,rd_cc.bounds.t,rd_cc.bounds.iE,rd_cc.meta.perm,rd_cc.meta.ty,rd_cc.renode_id)
+ csplit2.tag  := 1.U(1.W)
+ csplit2.valid:= 1.U(1.W)
+ 
+ //send_node_query(rs1_cc.renode_id, 1'b0);
+ //send_node_alloc();
+ //send_node_mut(rs1_cc.renode_id, NODE_SPLIT);
+ send_node_query_c.ins.revnode_id:=rs2_cc.renode_id
+ send_node_query_c.ins.synchronous:=0.U
+ //initial
+ //  send_node_query_c.ins.node_query_sent_q          := 0.U
+ //  send_node_query_c.ins.node_query_ready_i         := 0.U
+ //  send_node_query_c.ins.node_query_resp_valid_i    := 0.U
+ //  send_node_query_c.ins.node_query_resp_received_q := 0.U 
+ //  send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
+ //  send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
+ //  send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U 
+ 
+ send_node_mut_c.ins.revnode_id:=rs2_cc.renode_id
+ send_node_mut_c.ins.mut_ty:=node_mut_type_t.NODE_SPLIT
+ //initial
+ //  send_node_mut_c.ins.node_alloc_node_id_cur := 0.U 
+ //  send_node_mut_c.ins.have_alloc             := 0.U  
+ printf( "split send_node_mut_c.ins.mut_ty,%b , %b , %b %b\n",rs1_c.renode_id ,rs2_cc.renode_id, rs1_cc.renode_id, send_node_mut_c.ins.mut_ty)
+ printf( "split send_node_mut output %b,%b,%b\n",send_node_mut_c.ins.node_mut_valid_o, send_node_alloc_c.ins.node_alloc_valid_o,send_node_query_c.ins.node_query_valid_o )
 
 
-// rs1_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
-// rd_result_o = '{cap: 128'(rd_cc), tag: '1, valid: '1};
-
-csplit.cap:= Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)  
-csplit.tag:= 1.U(1.W)
-csplit.valid:= 1.U(1.W)
-
-csplit2.cap  := Cat(rd_cc.renode_id,rd_cc.meta.ty,rd_cc.meta.perm, rd_cc.renode_id, rd_cc.meta.ty , rd_cc.meta.perm, rd_cc.bounds.iE , rd_cc.bounds.t , rd_cc.bounds.tE , rd_cc.bounds.b , rd_cc.bounds.bE ,rd_cc.bounds.cursor)  
-csplit2.tag  := 1.U(1.W)
-csplit2.valid:= 1.U(1.W)
-
-//send_node_query(rs1_cc.renode_id, 1'b0);
-//send_node_alloc();
-//send_node_mut(rs1_cc.renode_id, NODE_SPLIT);
-  send_node_query_c.ins.revnode_id:=rs1_cc.renode_id
-  send_node_query_c.ins.synchronous:=0.U
-   //initial
-   send_node_query_c.ins.node_query_sent_q          := 0.U
-   send_node_query_c.ins.node_query_ready_i         := 0.U
-   send_node_query_c.ins.node_query_resp_valid_i    := 0.U
-   send_node_query_c.ins.node_query_resp_received_q := 0.U 
-   send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
-   send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
-   send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U 
-
-  send_node_mut_c.ins.revnode_id:=rs1_cc.renode_id
-  send_node_mut_c.ins.mut_ty:=node_mut_type_t.NODE_SPLIT
-  //initial
-  send_node_mut_c.ins.node_alloc_node_id_cur := 0.U 
-  send_node_mut_c.ins.have_alloc             := 0.U  
-  printf( "split send_node_mut_c.ins.mut_ty %b\n",send_node_mut_c.ins.mut_ty)
 }
 
 class csealModule(implicit p: Parameters) extends XSModule {
@@ -1492,15 +1633,15 @@ class csealModule(implicit p: Parameters) extends XSModule {
    val rs1_cc=Reg(new cap_cc_t)
    val rs1_c =Reg(new cap_fat_t)
 
-   rs1_cc.renode_id := Cat(src.cap_a(30,0))//31
-   rs1_cc.meta.ty   := Cat(src.cap_a(33,31)) //6
-   rs1_cc.meta.perm := Cat(src.cap_a(36,34)) //6
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37))    //1
-   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   rs1_cc.renode_id  := src.cap_a(30,0)//31
+   rs1_cc.meta.ty    := src.cap_a(33,31)//6
+   rs1_cc.meta.perm  := src.cap_a(36,34) //6
+   rs1_cc.bounds.iE  := src.cap_a(37) //1
+   rs1_cc.bounds.t   := src.cap_a(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+   rs1_cc.bounds.b   := src.cap_a(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
    
   val cap_uncompress_cap=Module(new cap_uncompress)
   val cap_compress_cap  =Module(new cap_compress)
@@ -1527,29 +1668,28 @@ class csealModule(implicit p: Parameters) extends XSModule {
    rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
    rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty 
 
+  printf( "seal param %b , %b , %b\n",src.tag_a, rs1_c.meta.ty,  rs1_cc.meta.perm)
 
-  // if (!(src.tag_a==0.U) || (rs1_c.meta.ty != cap_type_t.CAP_TYPE_LINEAR) || (rs1_cc.meta.perm !=cap_perm_t.CAP_PERM_RW))
-  when ((src.tag_a=/=0.U) && (rs1_c.meta.ty === cap_type_t.CAP_TYPE_LINEAR) && (rs1_cc.meta.perm =/=cap_perm_t.CAP_PERM_RW))
+  when ((src.tag_a=/=0.U) && (rs1_c.meta.ty =/= cap_type_t.CAP_TYPE_LINEAR) && (rs1_cc.meta.perm =/=cap_perm_t.CAP_PERM_RW))
   {
-    // error 
+     printf( "seal ex_o %b\n",ex_o_v)
      ex_o_v := 1.U
   }          
   
   val size = rs1_c.bounds.top - rs1_c.bounds.base
 
-  // if ((size < (CLENBYTES * 33.U(5.W))) || ((rs1_c.bounds.base & (CLENBYTES - 1.U(1.W)))))
   //if ((size < (CLENBYTES * 33 ))!=0.U || ((rs1_c.bounds.base & (CLENBYTES - 1.U))!=0.U))
-  // if ((size < (16 * 33 ))!=0.U || ((rs1_c.bounds.base & (16 - 1))!=0.U))
-  // if ((size < 528.U )!=0.U || ((rs1_c.bounds.base & 15.U)!=0.U))
-  when ((size < 528.U )=/=0.U || ((rs1_c.bounds.base & 15.U)=/=0.U))
+  when ((size < 528.U )=/=0.U || ((rs1_c.bounds.base & 15.U)=/=0.U))//ToDo check condition again
   {
+   printf( "seal ex_o %b\n",ex_o_v)
    ex_o_v := 1.U
   }
 
   rs1_c.meta.ty := cap_type_t.CAP_TYPE_SEALED
-  rs1_c.reg_id := 0.U(5.W)
-  rs1_c.async := 0.U(1.W)
-          
+  rs1_c.reg_id  := 0.U(5.W)
+  rs1_c.async   := 0.U(1.W)
+  printf( "seal changed type, ID and Async %b , %b , %b\n",rs1_c.meta.ty, rs1_c.reg_id,  rs1_c.async)
+       
  // check if base + clen, base + 2*clen mem location contains a capability
  // this probably means moving this insn to some other non-FLU unit
                 
@@ -1583,17 +1723,17 @@ class csealModule(implicit p: Parameters) extends XSModule {
   rs1_cc.meta.perm := cap_compress_cap.cap_cc.meta.perm
   rs1_cc.renode_id :=  cap_compress_cap.cap_cc.renode_id
 
-  cseal2.cap  := Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)  
+  cseal2.cap  := Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
   cseal2.tag  := 1.U(1.W)
   cseal2.valid:= 1.U(1.W)
 
-  }
+}
 
-  class cmrevModule (implicit p: Parameters) extends XSModule {
-    val src     = IO(Input(new fu_data_t))
-    val cmrev   = IO(Output(new cap_result_t ))  
-    val cmrev2  = IO(Output(new cap_result_t )) 
-    val  ex_o_v= IO(Output (UInt(1.W) ))
+class cmrevModule (implicit p: Parameters) extends XSModule {
+   val src     = IO(Input(new fu_data_t))
+   val cmrev   = IO(Output(new cap_result_t ))  
+   val cmrev2  = IO(Output(new cap_result_t )) 
+   val  ex_o_v= IO(Output (UInt(1.W) ))
 
    ex_o_v:=0.U
 
@@ -1615,21 +1755,25 @@ class csealModule(implicit p: Parameters) extends XSModule {
   // val rs1_cc=Wire(new cap_cc_t)
   val rs1_cc=Reg(new cap_cc_t)
 
-  rs1_cc.renode_id  := Cat(src.cap_a(30,0))//31
-  rs1_cc.meta.ty    := Cat(src.cap_a(33,31)) //6
-  rs1_cc.meta.perm  := Cat(src.cap_a(36,34)) //6
-  rs1_cc.bounds.iE  := Cat(src.cap_a(37))    //1
-  rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-  rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-  rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-  rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-  rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
-  // if ((src.tag_a!=0.U)&&(rs1_cc.meta.ty == cap_type_t.CAP_TYPE_LINEAR)) 
-  when ((src.tag_a=/=0.U)&&(rs1_cc.meta.ty === cap_type_t.CAP_TYPE_LINEAR)) 
+  val k = src.cap_a(33,31) //6
+
+  rs1_cc.renode_id  := src.cap_a(30,0)//31
+  rs1_cc.meta.ty    := src.cap_a(33,31) //6
+  rs1_cc.meta.perm  := src.cap_a(36,34) //6
+  rs1_cc.bounds.iE  := src.cap_a(37)   //1
+  rs1_cc.bounds.t   := src.cap_a(46,38) //9
+  rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+  rs1_cc.bounds.b   := src.cap_a(60,50) //11
+  rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+  rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
+
+  // when ((src.tag_a=/=0.U)&&(rs1_cc.meta.ty === cap_type_t.CAP_TYPE_LINEAR)) 
+  when ((src.tag_a=/=0.U)&&(k === cap_type_t.CAP_TYPE_LINEAR)) 
     {
     rs1_cc.meta.ty := cap_type_t.CAP_TYPE_REVOKE
- 
-    cmrev2.cap  := Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)  
+    printf( "mrev new type  %b\n",rs1_cc.meta.ty)
+
+    cmrev2.cap  := Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
     cmrev2.tag  := 1.U(1.W)
     cmrev2.valid:= 1.U(1.W)
 
@@ -1649,17 +1793,17 @@ class csealModule(implicit p: Parameters) extends XSModule {
 
      send_node_mut_c.ins.revnode_id:=rs1_cc.renode_id
      send_node_mut_c.ins.mut_ty:=node_mut_type_t.NODE_MREV
-    //initial
-    send_node_mut_c.ins.node_alloc_node_id_cur := 0.U 
-    send_node_mut_c.ins.have_alloc             := 0.U    
+     //initial
+     send_node_mut_c.ins.node_alloc_node_id_cur := 0.U 
+     send_node_mut_c.ins.have_alloc             := 0.U    
     }
-  // else
   .otherwise
   {
 
     cmrev2.cap  := 0.U
     cmrev2.tag  := 0.U(1.W)
     cmrev2.valid:= 0.U(1.W)
+    printf( "mrev ex_o\n")
 
     //error
     ex_o_v := 1.U
@@ -1669,9 +1813,8 @@ class csealModule(implicit p: Parameters) extends XSModule {
     cmrev.tag  := 0.U(1.W)
     cmrev.valid:= 0.U(1.W)
 
-  }
+}
 
-//  class cinitModule extends Module {
 class cinitModule (implicit p: Parameters) extends XSModule {
 
   val src = IO(Input(new fu_data_t))
@@ -1684,40 +1827,59 @@ class cinitModule (implicit p: Parameters) extends XSModule {
   val rs1_cc=Reg(new cap_cc_t)
   val rs1_c =Reg(new cap_fat_t)
 
+  val k1,k2 =Reg(UInt(64.W))
   val cap_uncompress_cap=Module(new cap_uncompress)
   val cap_compress_cap  =Module(new cap_compress)
 
+  rs1_cc.renode_id  := src.cap_a(30,0)//31
+  rs1_cc.meta.ty    := src.cap_a(33,31) //6
+  rs1_cc.meta.perm  := src.cap_a(36,34) //6
+  rs1_cc.bounds.iE  := src.cap_a(37)   //1
+  rs1_cc.bounds.t   := src.cap_a(46,38) //9
+  rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+  rs1_cc.bounds.b   := src.cap_a(60,50) //11
+  rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+  rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
+
   // cap_uncompress_cap.cap_cc:=rs1_cc
   // rs1_c := cap_uncompress_cap.cap_fat
-   cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
-   cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
-   cap_uncompress_cap.cap_cc.bounds.tE  :=rs1_cc.bounds.tE
-   cap_uncompress_cap.cap_cc.bounds.b   :=rs1_cc.bounds.b
-   cap_uncompress_cap.cap_cc.bounds.bE  :=rs1_cc.bounds.bE   
-   cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
-   cap_uncompress_cap.cap_cc.meta.ty     :=rs1_cc.meta.ty
-   cap_uncompress_cap.cap_cc.meta.perm   :=rs1_cc.meta.perm
-   cap_uncompress_cap.cap_cc.renode_id   :=rs1_cc.renode_id
-   
-   rs1_c.bounds.base   := cap_uncompress_cap.cap_fat.bounds.base
-   rs1_c.bounds.top    := cap_uncompress_cap.cap_fat.bounds.top
-   rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor   
+  cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
+  cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
+  cap_uncompress_cap.cap_cc.bounds.tE  :=rs1_cc.bounds.tE
+  cap_uncompress_cap.cap_cc.bounds.b   :=rs1_cc.bounds.b
+  cap_uncompress_cap.cap_cc.bounds.bE  :=rs1_cc.bounds.bE   
+  cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
+  cap_uncompress_cap.cap_cc.meta.ty     :=rs1_cc.meta.ty
+  cap_uncompress_cap.cap_cc.meta.perm   :=rs1_cc.meta.perm
+  cap_uncompress_cap.cap_cc.renode_id   :=rs1_cc.renode_id
+  
+  rs1_c.bounds.base   := cap_uncompress_cap.cap_fat.bounds.base
+  //  rs1_c.bounds.top    := cap_uncompress_cap.cap_fat.bounds.top
+  //  rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor  
+   k1                  := cap_uncompress_cap.cap_fat.bounds.top
+   k2                  := cap_uncompress_cap.cap_fat.bounds.cursor   
    rs1_c.renode_id     := cap_uncompress_cap.cap_fat.renode_id
    rs1_c.reg_id        := cap_uncompress_cap.cap_fat.reg_id
    rs1_c.async         := cap_uncompress_cap.cap_fat.async
    rs1_c.padding       := cap_uncompress_cap.cap_fat.padding
    rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
-   rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty 
+  //  rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty 
+   val k3       = cap_uncompress_cap.cap_fat.meta.ty 
 
-  // if ((src.tag_a==0.U) || (src.tag_b==1.U) || (rs1_c.meta.ty != cap_type_t.CAP_TYPE_UNINIT) || (rs1_c.bounds.cursor != rs1_c.bounds.top))         
-  when ((src.tag_a===0.U) || (src.tag_b===1.U) || (rs1_c.meta.ty =/= cap_type_t.CAP_TYPE_UNINIT) || (rs1_c.bounds.cursor =/= rs1_c.bounds.top))         
+   k1:=0.U
+   k2:=0.U
+
+  // when ((src.tag_a===0.U) || (src.tag_b===1.U) || (rs1_c.meta.ty =/= cap_type_t.CAP_TYPE_UNINIT) || (rs1_c.bounds.cursor =/= rs1_c.bounds.top))         
+  when ((src.tag_a===0.U) || (src.tag_b===1.U) || (k3 =/= cap_type_t.CAP_TYPE_UNINIT) || (k1 =/= k2))         
   {
-    //error/exeption
+    printf( "cinit ex_o\n")
     ex_o_v := 1.U
   }
 
   rs1_c.meta.ty := cap_type_t.CAP_TYPE_LINEAR
-  rs1_c.bounds.cursor := rs1_c.bounds.base + src.operand_b
+  rs1_c.bounds.cursor := rs1_c.bounds.base + src.operand_b(4,0)
+  
+  printf( "cinit, new type , base, vaue, cursor: %b, %b , %b , %b\n", rs1_c.meta.ty,rs1_c.bounds.base, src.operand_b(4,0), rs1_c.bounds.cursor )
 
   // cap_compress_cap.cap_fat:=rs1_c
   // rs1_cc:= cap_compress_cap.cap_cc
@@ -1746,13 +1908,11 @@ class cinitModule (implicit p: Parameters) extends XSModule {
   cinit.valid:= 1.U(1.W)
 
 
-  cinit2.cap:= Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)  
+  cinit2.cap:= Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
   cinit2.tag:= 1.U(1.W)
-
   cinit2.valid:= 1.U(1.W) 
   
   }
-//  class cmovcModule extends Module {
 class cmovcModule (implicit p: Parameters) extends XSModule {
 
   val src    = IO(Input(new fu_data_t))
@@ -1760,100 +1920,121 @@ class cmovcModule (implicit p: Parameters) extends XSModule {
   val cmovc2 = IO(Output(new cap_result_t ))
   val ex_o_v = IO(Output (UInt(1.W) ))
 
-    ex_o_v := 0.U
+  ex_o_v := 0.U
 
   //unpacked capability
   val rs1_cc=Wire(new cap_cc_t)
 
-  rs1_cc.renode_id := Cat(src.cap_a(30,0))//31
-  rs1_cc.meta.ty   := Cat(src.cap_a(33,31)) //6
-  rs1_cc.meta.perm  := Cat(src.cap_a(36,34)) //6
-  rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3
-  rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-  rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-  rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-  rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-  rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+  rs1_cc.renode_id := src.cap_a(30,0)//31
+  rs1_cc.meta.ty   := src.cap_a(33,31) //6
+  rs1_cc.meta.perm  :=src.cap_a(36,34) //6
+  rs1_cc.bounds.iE  :=src.cap_a(37) //3
+  rs1_cc.bounds.t   :=src.cap_a(46,38) //9
+  rs1_cc.bounds.tE  :=src.cap_a(49,47) //3
+  rs1_cc.bounds.b   :=src.cap_a(60,50) //11
+  rs1_cc.bounds.bE  :=src.cap_a(63,61)//3
+  rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
 
   when (src.tag_a===0.U)
   {
-    //error/exeption
-    ex_o_v := 1.U
- 
+  //error/exeption
+  ex_o_v := 1.U
+  printf( "mov ex_o \n")
   }
-   if (src.rs1 != src.rd)
-  //  if(rs1_cc.meta.ty== cap_type_t.CAP_TYPE_NONLIN)
-  // when (src.rs1 =/= src.rd)
+  printf( "mov rs,rd = %b, %b \n", src.rs1 , src.rd)
+
+  when (src.rs1 =/= src.rd)
+  {
    when(rs1_cc.meta.ty=== cap_type_t.CAP_TYPE_NONLIN) 
     {
-    cmovc.cap:= 0.U(CLEN.W)
-    cmovc.tag:= 0.U(1.W)
-    cmovc.valid:= 0.U(1.W)
-
-    cmovc2.cap:= src.cap_a
-    cmovc2.tag:= 1.U(1.W)
-    cmovc2.valid:= 1.U(1.W)
+     printf( "mov , done \n")
+     cmovc.cap:= 0.U(CLEN.W)
+     cmovc.tag:= 0.U(1.W)
+     cmovc.valid:= 0.U(1.W)
+
+     cmovc2.cap:= src.cap_a
+     cmovc2.tag:= 1.U(1.W)
+     cmovc2.valid:= 1.U(1.W)
     }
     // else 
     .otherwise
     {
+     printf( "mov , done \n")
+     cmovc.cap:= 0.U(CLEN.W)
+     cmovc.tag:= 0.U(1.W)
+     cmovc.valid:= 1.U(1.W)
+
+     cmovc2.cap:= src.cap_a
+     cmovc2.tag:= 1.U(1.W)
+     cmovc2.valid:= 1.U(1.W)
+    }
+  }
+  .otherwise{
+    printf( "mov , no_op \n")
     cmovc.cap:= 0.U(CLEN.W)
     cmovc.tag:= 0.U(1.W)
-    cmovc.valid:= 1.U(1.W)
+    cmovc.valid:= 0.U(1.W)
 
-    cmovc2.cap:= src.cap_a
-    cmovc2.tag:= 1.U(1.W)
-    cmovc2.valid:= 1.U(1.W)
-    }
+    cmovc2.cap:= 0.U
+    cmovc2.tag:= 0.U(1.W)
+    cmovc2.valid:= 0.U(1.W)
+  }
 
   }
 
-//  class cdropModule  extends Module {
-  class cdropModule (implicit p: Parameters) extends XSModule {
+class cdropModule (implicit p: Parameters) extends XSModule {
 
-  val src = IO(Input(new fu_data_t))
-  val cdrop  = IO(Output(new cap_result_t ))
-  val cdrop2 = IO(Output(new cap_result_t ))
-  val  ex_o_v= IO(Output (UInt(1.W) ))
+   val src = IO(Input(new fu_data_t))
+   val cdrop  = IO(Output(new cap_result_t ))
+   val cdrop2 = IO(Output(new cap_result_t ))
+   val  ex_o_v= IO(Output (UInt(1.W) ))
 
    ex_o_v:=0.U
 
-  val rs1_cc=Wire(new cap_cc_t)
-
-  rs1_cc.renode_id := Cat(src.cap_a(30,0))//31
-  rs1_cc.meta.ty   := Cat(src.cap_a(33,31)) //6
-  rs1_cc.meta.perm := Cat(src.cap_a(36,34)) //6
-  rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3 
-  rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-  rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-  rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-  rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-  rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   val rs1_cc=Wire(new cap_cc_t)
 
+   rs1_cc.renode_id := Cat(src.cap_a(30,0))//31
+   rs1_cc.meta.ty   := Cat(src.cap_a(33,31)) //6
+   rs1_cc.meta.perm := Cat(src.cap_a(36,34)) //6
+   rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3 
+   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
+   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
+   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
+   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
+   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
 
-  when (src.tag_a===0.U)
+   when (src.tag_a===0.U)
    {
+      printf( "drop ex_o %b\n",ex_o_v)
       ex_o_v := 1.U
    }
-  //   // validity check first?
-  //   // followed by a nodedrop 
-    cdrop.cap :=0.U 
-    cdrop.tag:= 1.U(1.W)
-    cdrop.valid:= 1.U(1.W)
-
-   cdrop2.cap :=0.U 
-   cdrop2.tag:= 1.U(1.W)
-   cdrop2.valid:= 1.U(1.W)
+    // validity check first?
+    // followed by a nodedrop 
+    // cannot change src as input data?!//ToDo//Capstone ?
+   when (src.valid===1.U)
+   {
+    printf( "drop , src is valid, change to invalid\n")
+    // src.valid:=0.U
+   }
+   .otherwise
+   {
+    printf( "drop , src is not valid, no-op\n")
+   }
 
- 
-  }
-//  class ccincoffsetModule extends Module {
-  class ccincoffsetModule (implicit p: Parameters) extends XSModule {
+   cdrop.cap :=0.U 
+   cdrop.tag:= 0.U(1.W)
+   cdrop.valid:= 0.U(1.W)
 
-  val src = IO(Input(new fu_data_t))
-  val ccincoffset  = IO(Output(new cap_result_t ))
-  val ccincoffset2 = IO(Output(new cap_result_t ))
-  val  ex_o_v= IO(Output (UInt(1.W) ))
+   cdrop2.cap :=0.U 
+   cdrop2.tag:= 0.U(1.W)
+   cdrop2.valid:= 0.U(1.W)
+}
+class ccincoffsetModule (implicit p: Parameters) extends XSModule 
+{
+   val src = IO(Input(new fu_data_t))
+   val ccincoffset  = IO(Output(new cap_result_t ))
+   val ccincoffset2 = IO(Output(new cap_result_t ))
+   val  ex_o_v= IO(Output (UInt(1.W) ))
 
    ex_o_v:=0.U
 
@@ -1863,22 +2044,22 @@ class cmovcModule (implicit p: Parameters) extends XSModule {
    val rs1_c =Reg(new cap_fat_t)
    val rs2   =Reg(UInt(XLEN.W))
     
-   rs1_cc.renode_id := src.cap_a(30,0)//31
-   rs1_cc.meta.ty   := src.cap_a(33,31) //6
-   rs1_cc.meta.perm := src.cap_a(36,34) //6
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3    
-   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   rs1_cc.renode_id  := src.cap_a(30,0)//31
+   rs1_cc.meta.ty    := src.cap_a(33,31) //6
+   rs1_cc.meta.perm  := src.cap_a(36,34) //6
+   rs1_cc.bounds.iE  := src.cap_a(37) //3    
+   rs1_cc.bounds.t   := src.cap_a(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+   rs1_cc.bounds.b   := src.cap_a(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
 
    
-  val cap_uncompress_cap=Module(new cap_uncompress)
-  val cap_compress_cap  =Module(new cap_compress)
+   val cap_uncompress_cap=Module(new cap_uncompress)
+   val cap_compress_cap  =Module(new cap_compress)
 
-  // cap_uncompress_cap.cap_cc:=rs1_cc
-  // rs1_c := cap_uncompress_cap.cap_fat
+   // cap_uncompress_cap.cap_cc:=rs1_cc
+   // rs1_c := cap_uncompress_cap.cap_fat
 
    cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
    cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
@@ -1900,116 +2081,231 @@ class cmovcModule (implicit p: Parameters) extends XSModule {
    rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
    rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty 
 
+   val k  = cap_uncompress_cap.cap_fat.bounds.cursor   
 
-  // if (src.tag_a==0.U || (src.tag_b!=0.U) || (rs1_c.meta.ty==cap_type_t.CAP_TYPE_UNINIT || rs1_c.meta.ty==cap_type_t.CAP_TYPE_SEALED))
-  when (src.tag_a===0.U || (src.tag_b=/=0.U) || (rs1_c.meta.ty===cap_type_t.CAP_TYPE_UNINIT || rs1_c.meta.ty===cap_type_t.CAP_TYPE_SEALED))
-   {
-     ex_o_v := 1.U
-   }
-
-  rs2 := src.operand_b
-
-  rs1_c.bounds.cursor := rs1_c.bounds.cursor + rs2
 
-  // cap_compress_cap.cap_fat:=rs1_c
-  // res := cap_compress_cap.cap_cc
-  cap_compress_cap.cap_fat.bounds.base:= rs1_c.bounds.base   
-  cap_compress_cap.cap_fat.bounds.top := rs1_c.bounds.top     
-  cap_compress_cap.cap_fat.bounds.cursor := rs1_c.bounds.cursor     
-  cap_compress_cap.cap_fat.renode_id  := rs1_c.renode_id      
-  cap_compress_cap.cap_fat.reg_id     :=rs1_c.reg_id         
-  cap_compress_cap.cap_fat.async      := rs1_c.async         
-  cap_compress_cap.cap_fat.padding := rs1_c.padding
-  cap_compress_cap.cap_fat.meta.perm := rs1_c.meta.perm 
-  cap_compress_cap.cap_fat.meta.ty := rs1_c.meta.ty 
-
-  res.bounds.iE := cap_compress_cap.cap_cc.bounds.iE
-  res.bounds.t  := cap_compress_cap.cap_cc.bounds.t
-  res.bounds.tE :=cap_compress_cap.cap_cc.bounds.tE
-  res.bounds.b  := cap_compress_cap.cap_cc.bounds.b
-  res.bounds.bE := cap_compress_cap.cap_cc.bounds.bE   
-  res.bounds.cursor := cap_compress_cap.cap_cc.bounds.cursor
-  res.meta.ty   := cap_compress_cap.cap_cc.meta.ty
-  res.meta.perm := cap_compress_cap.cap_cc.meta.perm
-  res.renode_id :=  cap_compress_cap.cap_cc.renode_id
+   when (src.tag_a===0.U || (src.tag_b=/=0.U) || (rs1_c.meta.ty===cap_type_t.CAP_TYPE_UNINIT || rs1_c.meta.ty===cap_type_t.CAP_TYPE_SEALED))
+   {
+    ex_o_v := 1.U
+    printf( "cincoffset ex_o \n")
 
+   }
 
-  when (src.rs1 === src.rd) 
-  {
-   ccincoffset.cap:= 0.U
-   ccincoffset.tag:= 0.U(1.W)
+   rs2 := src.operand_b(4,0)
+   rs1_c.bounds.cursor := k + rs2
+   printf("cincoffset old cursor, new cursor, offset : %b, %b, %b \n", k ,rs1_c.bounds.cursor, rs2)
+
+   // cap_compress_cap.cap_fat:=rs1_c
+   // res := cap_compress_cap.cap_cc
+   cap_compress_cap.cap_fat.bounds.base   := rs1_c.bounds.base   
+   cap_compress_cap.cap_fat.bounds.top    := rs1_c.bounds.top     
+   cap_compress_cap.cap_fat.bounds.cursor := rs1_c.bounds.cursor     
+   cap_compress_cap.cap_fat.renode_id  := rs1_c.renode_id      
+   cap_compress_cap.cap_fat.reg_id     :=rs1_c.reg_id         
+   cap_compress_cap.cap_fat.async      := rs1_c.async         
+   cap_compress_cap.cap_fat.padding    := rs1_c.padding
+   cap_compress_cap.cap_fat.meta.perm  := rs1_c.meta.perm 
+   cap_compress_cap.cap_fat.meta.ty    := rs1_c.meta.ty 
+
+   res.bounds.iE := cap_compress_cap.cap_cc.bounds.iE
+   res.bounds.t  := cap_compress_cap.cap_cc.bounds.t
+   res.bounds.tE := cap_compress_cap.cap_cc.bounds.tE
+   res.bounds.b  := cap_compress_cap.cap_cc.bounds.b
+   res.bounds.bE := cap_compress_cap.cap_cc.bounds.bE   
+   res.bounds.cursor := cap_compress_cap.cap_cc.bounds.cursor
+   res.meta.ty   :=  cap_compress_cap.cap_cc.meta.ty
+   res.meta.perm :=  cap_compress_cap.cap_cc.meta.perm
+   res.renode_id :=  cap_compress_cap.cap_cc.renode_id
+
+
+   when (src.rs1 === src.rd) 
+   {
+   ccincoffset.cap  := 0.U
+   ccincoffset.tag  := 0.U(1.W)
    ccincoffset.valid:= 0.U(1.W)
 
-   ccincoffset2.cap := Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)  
+   ccincoffset2.cap  := Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
    ccincoffset2.tag  := 1.U(1.W)
    ccincoffset2.valid:= 1.U(1.W)
-  }
-  .elsewhen (rs1_cc.meta.ty === cap_type_t.CAP_TYPE_NONLIN) 
-  {
-   ccincoffset.cap:= Cat(res.renode_id,res.meta.ty,res.meta.perm, res.renode_id, res.meta.ty , res.meta.perm, res.bounds.iE , res.bounds.t , res.bounds.tE , res.bounds.b , res.bounds.bE ,res.bounds.cursor)  
-   ccincoffset.tag:= 1.U(1.W)
-   ccincoffset.valid:= 1.U(1.W)
+   }
+   .elsewhen (rs1_cc.meta.ty === cap_type_t.CAP_TYPE_NONLIN) 
+   {
+    ccincoffset.cap  := Cat(res.bounds.cursor , res.bounds.b,res.bounds.bE,res.bounds.tE,res.bounds.t,res.bounds.iE,res.meta.perm,res.meta.ty,res.renode_id)
+    ccincoffset.tag  := 1.U(1.W)
+    ccincoffset.valid:= 1.U(1.W)
 
-   ccincoffset2.cap := Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)  
-   ccincoffset2.tag:= 1.U(1.W)
-   ccincoffset2.valid:= 1.U(1.W)
+    ccincoffset2.cap  := Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
+    ccincoffset2.tag  := 1.U(1.W)
+    ccincoffset2.valid:= 1.U(1.W)
 
-  }
-  .otherwise 
-  {// rs1 is a linear type
-   ccincoffset.cap:= 0.U(128.W)
-   ccincoffset.tag:= 0.U(1.W)
-   ccincoffset.valid:= 1.U(1.W)
+   }
+   .otherwise 
+   {// rs1 is a linear type
+    ccincoffset.cap  := 0.U(128.W)
+    ccincoffset.tag  := 0.U(1.W)
+    ccincoffset.valid:= 1.U(1.W)
  
 
-   ccincoffset2.cap:= Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)  
-   ccincoffset2.tag:= 1.U(1.W)
+   ccincoffset2.cap  :=Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
+   ccincoffset2.tag  := 1.U(1.W)
    ccincoffset2.valid:= 1.U(1.W)
     
-  }
+   }
 
-  }
-//  class ccallModule extends Module {
-  class ccallModule (implicit p: Parameters) extends XSModule {
-    val src = IO(Input(new fu_data_t))
-    val ccall  = IO(Output(new cap_result_t ))
-    val ccall2  = IO(Output(new cap_result_t ))
-    val ccall3  = IO(Output(new cap_result_t ))
-    val  ex_o_v= IO(Output (UInt(1.W) ))
+}
 
-    ex_o_v:=0.U
+class ccincoffsetimModule(implicit p: Parameters) extends XSModule {
+   val src = IO(Input(new fu_data_t))
+   val ccincoffsetim  = IO(Output(new cap_result_t ))
+   val ccincoffsetim2  = IO(Output(new cap_result_t ))
+   val ccincoffsetim3  = IO(Output(new cap_result_t ))
+   val  ex_o_v= IO(Output (UInt(1.W) ))
 
-    val rs1_cc =Reg(new cap_cc_t)
-    val rs1_c  =Reg(new cap_fat_t)
-    val cap_uncompress_cap=Module(new cap_uncompress)
-    val cap_compress_cap  =Module(new cap_compress)
+   ex_o_v:=0.U
 
+   val rs1_cc =Reg(new cap_cc_t)
+   val res    =Reg(new cap_cc_t)
+   val rs1_c  =Reg(new cap_fat_t)
+   val cap_uncompress_cap=Module(new cap_uncompress)
+   val cap_compress_cap  =Module(new cap_compress)
 
-   val send_node_query_ins  =IO(new send_node_query_bundle())
 
-   val send_node_query_c    = Module(new send_node_query)
+  rs1_cc.renode_id := src.cap_a(30,0)//31
+  rs1_cc.meta.ty    := src.cap_a(33,31) //6
+  rs1_cc.meta.perm  := src.cap_a(36,34) //6
+  rs1_cc.bounds.iE  := src.cap_a(37) //3    
+  rs1_cc.bounds.t   := src.cap_a(46,38) //9
+  rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+  rs1_cc.bounds.b   := src.cap_a(60,50) //11
+  rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+  rs1_cc.bounds.cursor  :=src.cap_a(127,64) //64
 
-   send_node_query_ins<>send_node_query_c.ins
 
+  //  cap_uncompress_cap.cap_cc:=rs1_cc
+  //  rs1_c := cap_uncompress_cap.cap_fat
+   cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
+   cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
+   cap_uncompress_cap.cap_cc.bounds.tE  :=rs1_cc.bounds.tE
+   cap_uncompress_cap.cap_cc.bounds.b   :=rs1_cc.bounds.b
+   cap_uncompress_cap.cap_cc.bounds.bE  :=rs1_cc.bounds.bE   
+   cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
+   cap_uncompress_cap.cap_cc.meta.ty     :=rs1_cc.meta.ty
+   cap_uncompress_cap.cap_cc.meta.perm   :=rs1_cc.meta.perm
+   cap_uncompress_cap.cap_cc.renode_id   :=rs1_cc.renode_id
+   
+   rs1_c.bounds.base   := cap_uncompress_cap.cap_fat.bounds.base
+   rs1_c.bounds.top    := cap_uncompress_cap.cap_fat.bounds.top
+   rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor   
+   rs1_c.renode_id     := cap_uncompress_cap.cap_fat.renode_id
+   rs1_c.reg_id        := cap_uncompress_cap.cap_fat.reg_id
+   rs1_c.async         := cap_uncompress_cap.cap_fat.async
+   rs1_c.padding       := cap_uncompress_cap.cap_fat.padding
+   rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
+   rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty
 
-   // $display("capstone %t: call (addr = %x, reg_id = %d)", $time, pc_cur, fu_data_cur.rd);
-   //if
-    when (src.rs1 === 0.U(5.W))
-    {
-      // rs1_cc = capstone::cap_cc_t'(cih_i);
-      // TODO: mark cih for later invalidation
-    }
-    .otherwise
-    {
-     rs1_cc.renode_id := src.cap_a(30,0)//31
-     rs1_cc.meta.ty    := src.cap_a(33,31) //6
-     rs1_cc.meta.perm  := src.cap_a(36,34) //6
-     rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3    
-     rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-     rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-     rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-     rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-     rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   val k = cap_uncompress_cap.cap_fat.bounds.cursor   
+
+   when (src.tag_a===0.U || (rs1_c.meta.ty===cap_type_t.CAP_TYPE_UNINIT || rs1_c.meta.ty===cap_type_t.CAP_TYPE_SEALED)) 
+   {
+    ex_o_v := 1.U
+    printf( "cincoffset ex_o_v \n")
+   }
+
+   rs1_c.bounds.cursor := k + src.imm(11,0)
+   printf( "cincoffsetimm old cursor, new cursor, imm : %b, %b, %b\n", k ,rs1_c.bounds.cursor, src.imm(11,0) )
+    
+   cap_compress_cap.cap_fat:=rs1_c
+   res := cap_compress_cap.cap_cc 
+  //  if (src.rs1 == src.rd)        
+   when (src.rs1 === src.rd)
+   {
+    // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1};
+    ccincoffsetim.cap  := 0.U(128.W)
+    ccincoffsetim.tag  := 0.U(1.W)
+    ccincoffsetim.valid:= 0.U(1.W) 
+
+    ccincoffsetim2.cap  :=Cat(res.bounds.cursor , res.bounds.b,res.bounds.bE,res.bounds.tE,res.bounds.t,res.bounds.iE,res.meta.perm,res.meta.ty,res.renode_id)
+    ccincoffsetim2.tag  := 1.U(1.W)
+    ccincoffsetim2.valid:= 1.U(1.W)     
+  
+    ccincoffsetim3.cap  := 0.U(128.W)
+    ccincoffsetim3.tag  := 0.U(1.W)
+    ccincoffsetim3.valid:= 0.U(1.W) 
+   } 
+   .elsewhen (rs1_cc.meta.ty === cap_type_t.CAP_TYPE_NONLIN)
+   {
+    // rs1_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
+    // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1}; 
+
+    ccincoffsetim.cap:= Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
+    ccincoffsetim.tag  := 1.U(1.W)
+    ccincoffsetim.valid:= 1.U(1.W) 
+
+    ccincoffsetim2.cap  :=Cat(res.bounds.cursor , res.bounds.b,res.bounds.bE,res.bounds.tE,res.bounds.t,res.bounds.iE,res.meta.perm,res.meta.ty,res.renode_id)
+    ccincoffsetim2.tag  := 1.U(1.W)
+    ccincoffsetim2.valid:= 1.U(1.W) 
+   
+    ccincoffsetim3.cap  := 0.U(128.W)
+    ccincoffsetim3.tag  := 0.U(1.W)
+    ccincoffsetim3.valid:= 0.U(1.W) 
+   }
+   .otherwise 
+   {// rs1 is a linear type
+    // rs1_result_o = '{cap: '0, tag: '0, valid: '1};
+    // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1};
+
+    ccincoffsetim.cap  := 0.U(128.W)
+    ccincoffsetim.tag  := 0.U(1.W)
+    ccincoffsetim.valid:= 1.U(1.W) 
+
+    ccincoffsetim2.cap  := 0.U(128.W)
+    ccincoffsetim2.tag  := 0.U(1.W)
+    ccincoffsetim2.valid:= 0.U(1.W) 
+
+    ccincoffsetim3.cap  := src.operand_b
+    ccincoffsetim3.tag  := 1.U(1.W)
+    ccincoffsetim3.valid:= 1.U(1.W)  
+   }
+}
+
+class ccallModule (implicit p: Parameters) extends XSModule 
+{
+  val src = IO(Input(new fu_data_t))
+  val ccall  = IO(Output(new cap_result_t ))
+  val ccall2  = IO(Output(new cap_result_t ))
+  val ccall3  = IO(Output(new cap_result_t ))
+  val  ex_o_v= IO(Output (UInt(1.W) ))
+
+  ex_o_v:=0.U
+
+  val rs1_cc =Reg(new cap_cc_t)
+  val rs1_c  =Reg(new cap_fat_t)
+  val cap_uncompress_cap=Module(new cap_uncompress)
+  val cap_compress_cap  =Module(new cap_compress)
+
+
+  val send_node_query_ins  =IO(new send_node_query_bundle())
+
+  val send_node_query_c    = Module(new send_node_query)
+
+  send_node_query_ins<>send_node_query_c.ins
+
+   when (src.rs1 === 0.U(5.W))
+   {
+     // rs1_cc = capstone::cap_cc_t'(cih_i);
+     // TODO: mark cih for later invalidation
+   }
+   .otherwise
+   {
+    rs1_cc.renode_id := src.cap_a(30,0)//31
+    rs1_cc.meta.ty    := src.cap_a(33,31) //6
+    rs1_cc.meta.perm  := src.cap_a(36,34) //6
+    rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3    
+    rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
+    rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
+    rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
+    rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
+    rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
 
     }
    
@@ -2067,8 +2363,8 @@ class cmovcModule (implicit p: Parameters) extends XSModule {
   rs1_cc.meta.perm := cap_compress_cap.cap_cc.meta.perm
   rs1_cc.renode_id :=  cap_compress_cap.cap_cc.renode_id
 
-  ccall3.cap  :=  Cat(rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor )
-  ccall3.tag  := 1.U(1.W)
+  ccall3.cap  :=  Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
+  ccall3.tag := 1.U(1.W)
   ccall3.valid:= 1.U(1.W)    
 
 
@@ -2093,17 +2389,17 @@ class cmovcModule (implicit p: Parameters) extends XSModule {
   send_node_query_c.ins.revnode_id:=rs1_c.renode_id
   send_node_query_c.ins.synchronous                :=0.U
   //initial value
-  send_node_query_c.ins.node_query_sent_q          := 0.U
-  send_node_query_c.ins.node_query_ready_i         := 0.U
-  send_node_query_c.ins.node_query_resp_valid_i    := 0.U
-  send_node_query_c.ins.node_query_resp_received_q := 0.U 
-  send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
-  send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
-  send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U    
-  }
+  // send_node_query_c.ins.node_query_sent_q          := 0.U
+  // send_node_query_c.ins.node_query_ready_i         := 0.U
+  // send_node_query_c.ins.node_query_resp_valid_i    := 0.U
+  // send_node_query_c.ins.node_query_resp_received_q := 0.U 
+  // send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
+  // send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
+  // send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U    
+}
 
-  class creturnModule (implicit p: Parameters) extends XSModule {
-//  class creturnModule extends Module {
+class creturnModule (implicit p: Parameters) extends XSModule 
+{
    val src = IO(Input(new fu_data_t))
    val creturn   = IO(Output(new cap_result_t ))
    val creturn2  = IO(Output(new cap_result_t ))
@@ -2152,10 +2448,10 @@ class cmovcModule (implicit p: Parameters) extends XSModule {
    rd_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
    rd_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty
 
-  when (rd_c.meta.ty =/= cap_type_t.CAP_TYPE_SEALEDRET)
-  {
-    ex_o_v := 1.U
-  }
+   when (rd_c.meta.ty =/= cap_type_t.CAP_TYPE_SEALEDRET)
+   {
+     ex_o_v := 1.U
+   }
 
   rd_c.meta.ty := cap_type_t.CAP_TYPE_SEALED
   rd_c.bounds.cursor := rd_c.bounds.base
@@ -2184,272 +2480,135 @@ class cmovcModule (implicit p: Parameters) extends XSModule {
   rd_cc.meta.perm := cap_compress_cap.cap_cc.meta.perm
   rd_cc.renode_id :=  cap_compress_cap.cap_cc.renode_id
 
-  // $display("Return to %s", cap_type_t.cap_cc_format(rd_cc));
-  creturn2.cap  := Cat(rd_cc.renode_id,rd_cc.meta.ty,rd_cc.meta.perm, rd_cc.renode_id, rd_cc.meta.ty , rd_cc.meta.perm, rd_cc.bounds.iE , rd_cc.bounds.t , rd_cc.bounds.tE , rd_cc.bounds.b , rd_cc.bounds.bE ,rd_cc.bounds.cursor)  
-  creturn2.tag  := 1.U(1.W)
-  creturn2.valid:= 1.U(1.W)   
-
-  // $display("capstone return (writing to %d: %s) @ %t", rd_c.reg_id, capstone::cap_fat_format(rd_c), $time);
-
-  // dom_switch_valid_o = 1'b1;
-  // dom_switch_req_o.dom_base = rd_c.bounds.base;
-  // dom_switch_req_o.out_dom_base = rd_c.bounds.base;
-  // dom_switch_req_o.trans_id = fu_data_cur.trans_id;
-  // dom_switch_req_o.is_full = rd_c.async;
-  // dom_switch_req_o.is_return = 1'b1;
-  // dom_switch_req_o.pc_out = fu_data_cur.operand_a; // PC is in rs1
-  // capstone_valid_o = '1;
-
-  // rs2 provides the posted interrupts, which will be set in the
-  // commit stage
-  creturn3.cap  := src.operand_b
-  creturn3.tag  := 0.U(1.W)
-  creturn3.valid:= 1.U(1.W) 
-
-  creturn.cap  := 0.U
-  creturn.tag  := 0.U(1.W)
-  creturn.valid:= 1.U(1.W) 
-
-  // send_node_query(rd_c.renode_id, 1'b0);
-  send_node_query_c.ins.revnode_id:=rd_c.renode_id
-  send_node_query_c.ins.synchronous:=0.U
-  
-  //initial value
-  send_node_query_c.ins.node_query_sent_q          := 0.U
-  send_node_query_c.ins.node_query_ready_i         := 0.U
-  send_node_query_c.ins.node_query_resp_valid_i    := 0.U
-  send_node_query_c.ins.node_query_resp_received_q := 0.U 
-  send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
-  send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
-  send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U  
-  }
-
-  class ccjalrModule (implicit p: Parameters) extends XSModule {
-// class ccjalrModule  extends Module {
-  val src = IO(Input(new fu_data_t))
-  val ccjalr  = IO(Output(new cap_result_t ))
-    ccjalr.cap  := 0.U
-    ccjalr.tag  := 0.U(1.W)
-    ccjalr.valid:= 0.U(1.W)   
-  }
-//  class ccbnzModule extends Module {
- class ccbnzModule (implicit p: Parameters) extends XSModule {
-
-  val src = IO(Input(new fu_data_t))
-  val ccbnz  = IO(Output(new cap_result_t ))
-    ccbnz.cap  := 0.U
-    ccbnz.tag  := 0.U(1.W)
-    ccbnz.valid:= 0.U(1.W)   
-  }
- class cccsrrwModule (implicit p: Parameters) extends XSModule {
-//  class cccsrrwModule extends Module {
- 
-  val src = IO(Input(new fu_data_t))
-  val cccsrrw  = IO(Output(new cap_result_t ))
-    cccsrrw.cap  := 0.U
-    cccsrrw.tag  := 0.U(1.W)
-    cccsrrw.valid:= 0.U(1.W)    
-  }
-
-  class ccincoffsetimModule(implicit p: Parameters) extends XSModule {
-// class ccincoffsetimModule  extends Module {
-   val src = IO(Input(new fu_data_t))
-   val ccincoffsetim  = IO(Output(new cap_result_t ))
-   val ccincoffsetim2  = IO(Output(new cap_result_t ))
-   val ccincoffsetim3  = IO(Output(new cap_result_t ))
-   val  ex_o_v= IO(Output (UInt(1.W) ))
-
-   ex_o_v:=0.U
-
-   val rs1_cc =Reg(new cap_cc_t)
-   val res    =Reg(new cap_cc_t)
-   val rs1_c  =Reg(new cap_fat_t)
-   val cap_uncompress_cap=Module(new cap_uncompress)
-   val cap_compress_cap  =Module(new cap_compress)
-
-
-  rs1_cc.renode_id := src.cap_a(30,0)//31
-  rs1_cc.meta.ty    := src.cap_a(33,31) //6
-  rs1_cc.meta.perm  := src.cap_a(36,34) //6
-  rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3    
-  rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-  rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-  rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-  rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-  rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
-
-
-  //  cap_uncompress_cap.cap_cc:=rs1_cc
-  //  rs1_c := cap_uncompress_cap.cap_fat
-   cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
-   cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
-   cap_uncompress_cap.cap_cc.bounds.tE  :=rs1_cc.bounds.tE
-   cap_uncompress_cap.cap_cc.bounds.b   :=rs1_cc.bounds.b
-   cap_uncompress_cap.cap_cc.bounds.bE  :=rs1_cc.bounds.bE   
-   cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
-   cap_uncompress_cap.cap_cc.meta.ty     :=rs1_cc.meta.ty
-   cap_uncompress_cap.cap_cc.meta.perm   :=rs1_cc.meta.perm
-   cap_uncompress_cap.cap_cc.renode_id   :=rs1_cc.renode_id
-   
-   rs1_c.bounds.base   := cap_uncompress_cap.cap_fat.bounds.base
-   rs1_c.bounds.top    := cap_uncompress_cap.cap_fat.bounds.top
-   rs1_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor   
-   rs1_c.renode_id     := cap_uncompress_cap.cap_fat.renode_id
-   rs1_c.reg_id        := cap_uncompress_cap.cap_fat.reg_id
-   rs1_c.async         := cap_uncompress_cap.cap_fat.async
-   rs1_c.padding       := cap_uncompress_cap.cap_fat.padding
-   rs1_c.meta.perm     := cap_uncompress_cap.cap_fat.meta.perm
-   rs1_c.meta.ty       := cap_uncompress_cap.cap_fat.meta.ty
-  //  if (src.tag_a==0.U || (rs1_c.meta.ty==cap_type_t.CAP_TYPE_UNINIT || rs1_c.meta.ty==cap_type_t.CAP_TYPE_SEALED)) 
-   when (src.tag_a===0.U || (rs1_c.meta.ty===cap_type_t.CAP_TYPE_UNINIT || rs1_c.meta.ty===cap_type_t.CAP_TYPE_SEALED)) 
-   {
-    ex_o_v := 1.U
-   }
-
-   rs1_c.bounds.cursor := rs1_c.bounds.cursor + src.imm
-    
-   cap_compress_cap.cap_fat:=rs1_c
-   res := cap_compress_cap.cap_cc 
-  //  if (src.rs1 == src.rd)        
-   when (src.rs1 === src.rd)
-   {
-    // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1};
-    ccincoffsetim.cap  := 0.U(128.W)
-    ccincoffsetim.tag  := 0.U(1.W)
-    ccincoffsetim.valid:= 0.U(1.W) 
-
-    ccincoffsetim2.cap  :=Cat(res.renode_id,res.meta.ty,res.meta.perm, res.renode_id, res.meta.ty , res.meta.perm, res.bounds.iE , res.bounds.t , res.bounds.tE , res.bounds.b , res.bounds.bE ,res.bounds.cursor)   
-    ccincoffsetim2.tag  := 1.U(1.W)
-    ccincoffsetim2.valid:= 1.U(1.W)     
-  
-    ccincoffsetim3.cap  := 0.U(128.W)
-    ccincoffsetim3.tag  := 0.U(1.W)
-    ccincoffsetim3.valid:= 0.U(1.W) 
-   } 
-   .elsewhen (rs1_cc.meta.ty === cap_type_t.CAP_TYPE_NONLIN)
-   {
-    // rs1_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
-    // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1}; 
-
-    ccincoffsetim.cap:= Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , res.bounds.tE , res.bounds.b , res.bounds.bE ,res.bounds.cursor)   
-    ccincoffsetim.tag:= 1.U(1.W)
-    ccincoffsetim.valid:= 1.U(1.W) 
-
-    ccincoffsetim2.cap  :=Cat(res.renode_id,res.meta.ty,res.meta.perm, res.renode_id, res.meta.ty , res.meta.perm, res.bounds.iE , res.bounds.t , res.bounds.tE , res.bounds.b , res.bounds.bE ,res.bounds.cursor)   
-    ccincoffsetim2.tag  := 1.U(1.W)
-    ccincoffsetim2.valid:= 1.U(1.W) 
-   
-    ccincoffsetim3.cap  := 0.U(128.W)
-    ccincoffsetim3.tag  := 0.U(1.W)
-    ccincoffsetim3.valid:= 0.U(1.W) 
-   }
-   .otherwise 
-   {// rs1 is a linear type
-    // rs1_result_o = '{cap: '0, tag: '0, valid: '1};
-    // rd_result_o = '{cap: 128'(res), tag: '1, valid: '1};
-
-    ccincoffsetim.cap  := 0.U(128.W)
-    ccincoffsetim.tag  := 0.U(1.W)
-    ccincoffsetim.valid:= 1.U(1.W) 
+  // $display("Return to %s", cap_type_t.cap_cc_format(rd_cc));
+  creturn2.cap  := Cat(rd_cc.bounds.cursor , rd_cc.bounds.b,rd_cc.bounds.bE,rd_cc.bounds.tE,rd_cc.bounds.t,rd_cc.bounds.iE,rd_cc.meta.perm,rd_cc.meta.ty,rd_cc.renode_id)
+  creturn2.tag  := 1.U(1.W)
+  creturn2.valid:= 1.U(1.W)   
 
-    ccincoffsetim2.cap  := 0.U(128.W)
-    ccincoffsetim2.tag  := 0.U(1.W)
-    ccincoffsetim2.valid:= 0.U(1.W) 
+  // $display("capstone return (writing to %d: %s) @ %t", rd_c.reg_id, capstone::cap_fat_format(rd_c), $time);
 
-    ccincoffsetim3.cap := src.operand_b
-    ccincoffsetim3.tag:= 1.U(1.W)
-    ccincoffsetim3.valid:= 1.U(1.W)  
-   }
-  }
+  // dom_switch_valid_o = 1'b1;
+  // dom_switch_req_o.dom_base = rd_c.bounds.base;
+  // dom_switch_req_o.out_dom_base = rd_c.bounds.base;
+  // dom_switch_req_o.trans_id = fu_data_cur.trans_id;
+  // dom_switch_req_o.is_full = rd_c.async;
+  // dom_switch_req_o.is_return = 1'b1;
+  // dom_switch_req_o.pc_out = fu_data_cur.operand_a; // PC is in rs1
+  // capstone_valid_o = '1;
 
- class cshrinktoModule(implicit p: Parameters) extends XSModule {
-//  class cshrinktoModule  extends Module {
-  // val io = IO(new Bundle() {
-  //   val src = Input(UInt(XLEN.W))
-  //   val cshrinkto = Output(UInt(XLEN.W))
-  // })
-    val src = IO(Input(new fu_data_t))
-    val cshrinkto  = IO(Output(new cap_result_t ))
+  // rs2 provides the posted interrupts, which will be set in the
+  // commit stage
+  creturn3.cap  := src.operand_b
+  creturn3.tag  := 0.U(1.W)
+  creturn3.valid:= 1.U(1.W) 
+
+  creturn.cap  := 0.U
+  creturn.tag  := 0.U(1.W)
+  creturn.valid:= 1.U(1.W) 
+
+  // send_node_query(rd_c.renode_id, 1'b0);
+  send_node_query_c.ins.revnode_id:=rd_c.renode_id
+  send_node_query_c.ins.synchronous:=0.U
   
-    cshrinkto.cap  := 0.U
-    cshrinkto.tag  := 0.U(1.W)
-    cshrinkto.valid:= 0.U(1.W)  
+  // //initial value
+  // send_node_query_c.ins.node_query_sent_q          := 0.U
+  // send_node_query_c.ins.node_query_ready_i         := 0.U
+  // send_node_query_c.ins.node_query_resp_valid_i    := 0.U
+  // send_node_query_c.ins.node_query_resp_received_q := 0.U 
+  // send_node_query_c.ins.node_query_resp_i.synchronous   := 0.U   
+  // send_node_query_c.ins.node_query_resp_i.trans_id      := 0.U    
+  // send_node_query_c.ins.node_query_resp_i.r_valid       := 0.U  
+}
 
-  }
+class ccjalrModule (implicit p: Parameters) extends XSModule {
+  val src = IO(Input(new fu_data_t))
+  val ccjalr  = IO(Output(new cap_result_t ))
+    ccjalr.cap  := 0.U
+    ccjalr.tag  := 0.U(1.W)
+    ccjalr.valid:= 0.U(1.W)   
+}
+class ccbnzModule (implicit p: Parameters) extends XSModule {
 
- class ccapenterModule(implicit p: Parameters) extends XSModule {
-//  class ccapenterModule extends Module {
-    val send_node_mut_ins  =IO(new send_node_mut_bundle())
-    val send_node_mut_c    = Module(new send_node_mut)
-    send_node_mut_ins<>send_node_mut_c.ins
+  val src = IO(Input(new fu_data_t))
+  val ccbnz  = IO(Output(new cap_result_t ))
+    ccbnz.cap  := 0.U
+    ccbnz.tag  := 0.U(1.W)
+    ccbnz.valid:= 0.U(1.W)   
+}
+class cccsrrwModule (implicit p: Parameters) extends XSModule {
+ 
+  val src = IO(Input(new fu_data_t))
+  val cccsrrw  = IO(Output(new cap_result_t ))
+    cccsrrw.cap  := 0.U
+    cccsrrw.tag  := 0.U(1.W)
+    cccsrrw.valid:= 0.U(1.W)    
+}
 
-    val src = IO(Input(new fu_data_t))
-    val ccapenter  = IO(Output(new cap_result_t ))
 
-   val cap0, cap1, pc_cap  =Wire(new cap_fat_t)
+class ccapenterModule(implicit p: Parameters) extends XSModule {
+  val send_node_mut_ins  =IO(new send_node_mut_bundle())
+  val send_node_mut_c    = Module(new send_node_mut)
+  send_node_mut_ins<>send_node_mut_c.ins
 
- 
-   
-   val lo = Wire(UInt(XLEN.W))
-   lo:=0.U
-   val hi = Wire(UInt(XLEN.W))
-   hi:=0.U
-// if
-   when((src.rs1 === 0.U(5.W)) && (src.rs2 === 0.U(5.W))) 
-   {
-    lo := 0x40.U(XLEN.W)
-    hi := 0x40.U(XLEN.W)
-    }
-    .otherwise//else
-    {
-     lo := src.operand_a
-     hi := src.operand_b
-    }
-    cap0.bounds.cursor:=  0.U(64.W)
-    cap0.bounds.base:=  0.U(64.W)
-    cap0.bounds.top:= lo
-    cap0.reg_id   := 0.U(1.W)
-    cap0.async    := 0.U(1.W)
-    cap0.meta.ty  :=cap_type_t.CAP_TYPE_LINEAR
-    cap0.meta.perm:=cap_perm_t.CAP_PERM_RWX
-    cap0.renode_id:= 0.U(31.W)
-    cap0.padding  := 0.U
-            
-    cap1.bounds.cursor:=  hi
-    cap1.bounds.base  :=  hi
-    cap1.bounds.top:=0.U(64.W)
-    cap1.reg_id   := 0.U(1.W)
-    cap1.async    := 1.U(1.W)
-    cap1.meta.ty  :=cap_type_t.CAP_TYPE_LINEAR
-    cap1.meta.perm:=cap_perm_t.CAP_PERM_RWX
-    cap1.renode_id:= 1.U(31.W)
-    cap1.padding  := 0.U
-
-    pc_cap.bounds.cursor:= lo
-    pc_cap.bounds.base:=  lo
-    pc_cap.bounds.top:= hi
-    pc_cap.reg_id   := 0.U(1.W)
-    pc_cap.async    := 1.U(1.W)
-    pc_cap.meta.ty  :=cap_type_t.CAP_TYPE_LINEAR
-    pc_cap.meta.perm:=cap_perm_t.CAP_PERM_RWX
-    pc_cap.renode_id:= 2.U(31.W)
-    pc_cap.padding  := 0.U
-
-    // cms_result_o = '{
-    //  cap0: capstone::cap_compress(cap0),
-    //  cap1: capstone::cap_compress(cap1),
-    //  pc_cap: capstone::cap_compress(pc_cap),
-    //  valid: '1
+  val src = IO(Input(new fu_data_t))
+  val ccapenter  = IO(Output(new cap_result_t ))
+
+  val cap0, cap1, pc_cap  =Wire(new cap_fat_t)
 
+  
+  val lo = Wire(UInt(XLEN.W))
+  lo:=0.U
+  val hi = Wire(UInt(XLEN.W))
+  hi:=0.U
+  when((src.rs1 === 0.U(5.W)) && (src.rs2 === 0.U(5.W))) 
+  {
+   lo := 0x40.U(XLEN.W)
+   hi := 0x40.U(XLEN.W)
+   }
+   .otherwise//else
+   {
+    lo := src.operand_a
+    hi := src.operand_b
+   }
+   cap0.bounds.cursor:=  0.U(64.W)
+   cap0.bounds.base:=  0.U(64.W)
+   cap0.bounds.top:= lo
+   cap0.reg_id   := 0.U(1.W)
+   cap0.async    := 0.U(1.W)
+   cap0.meta.ty  :=cap_type_t.CAP_TYPE_LINEAR
+   cap0.meta.perm:=cap_perm_t.CAP_PERM_RWX
+   cap0.renode_id:= 0.U(31.W)
+   cap0.padding  := 0.U
+           
+   cap1.bounds.cursor:=  hi
+   cap1.bounds.base  :=  hi
+   cap1.bounds.top:=0.U(64.W)
+   cap1.reg_id   := 0.U(1.W)
+   cap1.async    := 1.U(1.W)
+   cap1.meta.ty  :=cap_type_t.CAP_TYPE_LINEAR
+   cap1.meta.perm:=cap_perm_t.CAP_PERM_RWX
+   cap1.renode_id:= 1.U(31.W)
+   cap1.padding  := 0.U
+   pc_cap.bounds.cursor:= lo
+   pc_cap.bounds.base:=  lo
+   pc_cap.bounds.top:= hi
+   pc_cap.reg_id   := 0.U(1.W)
+   pc_cap.async    := 1.U(1.W)
+   pc_cap.meta.ty  :=cap_type_t.CAP_TYPE_LINEAR
+   pc_cap.meta.perm:=cap_perm_t.CAP_PERM_RWX
+   pc_cap.renode_id:= 2.U(31.W)
+   pc_cap.padding  := 0.U
+   // cms_result_o = '{
+   //  cap0: capstone::cap_compress(cap0),
+   //  cap1: capstone::cap_compress(cap1),
+   //  pc_cap: capstone::cap_compress(pc_cap),
+   //  valid: '1
   // send_node_mut(capstone::CAP_renode_id_NULL, NODE_INIT);
-     send_node_mut_c.ins.revnode_id:=CAP_REVNODE_ID_NULL
-     send_node_mut_c.ins.mut_ty:=node_mut_type_t.NODE_INIT
+   send_node_mut_c.ins.revnode_id:=CAP_REVNODE_ID_NULL
+   send_node_mut_c.ins.mut_ty:=node_mut_type_t.NODE_INIT
     //initial
-    send_node_mut_c.ins.node_alloc_node_id_cur := 0.U 
-    send_node_mut_c.ins.have_alloc             := 0.U 
-  // Debug Info//mlabaf
-  //printf("instruction in alu is capstone print")  
- // XSDebug("instruction is capstone XSD=%b\n",io.src)
+  send_node_mut_c.ins.node_alloc_node_id_cur := 0.U 
+  send_node_mut_c.ins.have_alloc             := 0.U 
   
   ccapenter.cap  := 0.U(128.W) 
   ccapenter.tag  := 0.U(1.W)
@@ -2457,11 +2616,6 @@ class cmovcModule (implicit p: Parameters) extends XSModule {
 }
 
 class ccreateModule(implicit p: Parameters) extends XSModule {
-//  class ccreateModule extends Module {
-  // val io = IO(new Bundle() {
-  //   val src = Input(UInt(XLEN.W))
-  //   val ccreate = Output(UInt(XLEN.W))
-  // })
   val src = IO(Input(new fu_data_t))
   val ccreate  = IO(Output(new cap_result_t ))
   val ccreate2  = IO(Output(new cap_result_t ))
@@ -2487,21 +2641,20 @@ class ccreateModule(implicit p: Parameters) extends XSModule {
   send_node_mut_c.ins.have_alloc             := 0.U   
   }
 class ctypeModule(implicit p: Parameters) extends XSModule {
-//  class ctypeModule extends Module {
     val src = IO(Input(new fu_data_t))
     val ctype  = IO(Output(new cap_result_t ))
     val ctype2  = IO(Output(new cap_result_t ))
     val rs1_cc=Wire(new cap_cc_t)
 
-   rs1_cc.renode_id   := Cat(src.cap_a(30,0))//31
-   rs1_cc.meta.ty     := Cat(src.cap_a(33,31)) //6
-   rs1_cc.meta.perm   := Cat(src.cap_a(36,34)) //6
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3  
-   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   rs1_cc.renode_id   := src.cap_a(30,0)//31
+   rs1_cc.meta.ty     := src.operand_a(2,0)//src.cap_a(33,31) //6
+   rs1_cc.meta.perm   := src.cap_a(36,34) //6
+   rs1_cc.bounds.iE   := src.cap_a(37) //3  
+   rs1_cc.bounds.t    := src.cap_a(46,38) //9
+   rs1_cc.bounds.tE   := src.cap_a(49,47) //3
+   rs1_cc.bounds.b    := src.cap_a(60,50) //11
+   rs1_cc.bounds.bE   := src.cap_a(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
 
   //rd_result_o = '{cap: 128'(rs1_cc), tag: '1, valid: '1};
 
@@ -2509,64 +2662,56 @@ class ctypeModule(implicit p: Parameters) extends XSModule {
   ctype.tag  := 0.U(1.W)
   ctype.valid:= 0.U(1.W)
 
-  ctype2.cap  :=Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)    
+  ctype2.cap  :=Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
   ctype2.tag  := 1.U(1.W)
   ctype2.valid:= 1.U(1.W)  
   }
 
 
 class cnodeModule(implicit p: Parameters) extends XSModule {
-//  class cnodeModule extends Module {
-  // val io = IO(new Bundle() {
-  //   val src = Input(UInt(XLEN.W))
-  //   val cnode = Output(UInt(XLEN.W))
-  // })
+
    val src = IO(Input(new fu_data_t))
    val cnode  = IO(Output(new cap_result_t ))
    val cnode2  = IO(Output(new cap_result_t ))
    val rs1_cc=Wire(new cap_cc_t)
 
 
-   rs1_cc.renode_id := Cat(src.cap_a(30,0))//31
-   rs1_cc.meta.ty  := Cat(src.cap_a(33,31)) //6
-   rs1_cc.meta.perm    := Cat(src.cap_a(36,34)) //6
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3
-   rs1_cc.bounds.t   := Cat(src.cap_a(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_a(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_a(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_a(63,61))//3
+   rs1_cc.renode_id  := src.cap_a(30,0)//31
+   rs1_cc.meta.ty    := src.cap_a(33,31) //6
+   rs1_cc.meta.perm  := src.cap_a(36,34) //6
+   rs1_cc.bounds.iE  := src.cap_a(37) //3
+   rs1_cc.bounds.t   := src.cap_a(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+   rs1_cc.bounds.b   := src.cap_a(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_a(63,61)//3
    rs1_cc.renode_id := src.operand_a
-   rs1_cc.bounds.cursor  := Cat(src.cap_a(127,64)) //64
+   rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
 
   cnode.cap  := 0.U(128.W) 
   cnode.tag  := 0.U(1.W)
   cnode.valid:= 0.U(1.W)
 
-  cnode2.cap := Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)    
+  cnode2.cap := Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
   cnode2.tag := 1.U(1.W)
   cnode2.valid:= 1.U(1.W) 
 
   }
 class cpermModule(implicit p: Parameters) extends XSModule {
-//  class cpermModule extends Module {
-  // val io = IO(new Bundle() {
-  //   val src = Input(UInt(XLEN.W))
-  //   val cperm = Output(UInt(XLEN.W))
-  // })
+
    val src = IO(Input(new fu_data_t))
    val cperm  = IO(Output(new cap_result_t ))
    val cperm2  = IO(Output(new cap_result_t ))
    val rs1_cc=Wire(new cap_cc_t)
 
    rs1_cc.renode_id := src.cap_c(30,0)//31
-   rs1_cc.meta.ty   := src.operand_a
-   rs1_cc.meta.perm := src.operand_a
-   rs1_cc.bounds.iE  := Cat(src.cap_c(37)) //3
-   rs1_cc.bounds.t   := Cat(src.cap_c(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_c(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_c(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_c(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_c(127,64)) //64
+   rs1_cc.meta.ty   := src.operand_a(2,0)
+   rs1_cc.meta.perm := src.operand_a(2,0)
+   rs1_cc.bounds.iE  := src.cap_c(37) //3
+   rs1_cc.bounds.t   := src.cap_c(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_c(49,47) //3
+   rs1_cc.bounds.b   := src.cap_c(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_c(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_c(127,64) //64
 
   cperm.cap  := 0.U(128.W) 
   cperm.tag  := 0.U(1.W)
@@ -2576,13 +2721,8 @@ class cpermModule(implicit p: Parameters) extends XSModule {
   cperm2.tag:= 1.U(1.W)
   cperm2.valid:= 1.U(1.W) 
 
-  }
+}
 class cboundModule(implicit p: Parameters) extends XSModule {
-//  class cboundModule  extends Module {
-  // val io = IO(new Bundle() {
-  //   val src = Input(UInt(XLEN.W))
-  //   val cbound = Output(UInt(XLEN.W))
-  // })
    val src      = IO(Input(new fu_data_t))
    val cbound   = IO(Output(new cap_result_t ))
    val cbound2  = IO(Output(new cap_result_t ))
@@ -2603,8 +2743,8 @@ class cboundModule(implicit p: Parameters) extends XSModule {
    rs1_cc.bounds.cursor  := Cat(src.cap_c(127,64)) //64
 
 
-  // cap_uncompress_cap.cap_cc:=rs1_cc
-  // rs1_c := cap_uncompress_cap.cap_fat
+   // cap_uncompress_cap.cap_cc:=rs1_cc
+   // rs1_c := cap_uncompress_cap.cap_fat
    cap_uncompress_cap.cap_cc.bounds.iE  :=rs1_cc.bounds.iE
    cap_uncompress_cap.cap_cc.bounds.t   :=rs1_cc.bounds.t
    cap_uncompress_cap.cap_cc.bounds.tE  :=rs1_cc.bounds.tE
@@ -2629,9 +2769,6 @@ class cboundModule(implicit p: Parameters) extends XSModule {
   rs1_c.bounds.base   := src.operand_a
   rs1_c.bounds.top    := src.operand_b
 
-//  cap_compress_cap.cap_fat:=rs1_c
-//  rs1_cc:= cap_compress_cap.cap_cc
-
   cap_compress_cap.cap_fat.bounds.base:= rs1_c.bounds.base   
   cap_compress_cap.cap_fat.bounds.top := rs1_c.bounds.top     
   cap_compress_cap.cap_fat.bounds.cursor := rs1_c.bounds.cursor     
@@ -2656,14 +2793,12 @@ class cboundModule(implicit p: Parameters) extends XSModule {
   cbound.tag  := 0.U(1.W)
   cbound.valid:= 0.U(1.W)
 
-  cbound2.cap:= Cat(rs1_cc.renode_id,rs1_cc.meta.ty,rs1_cc.meta.perm, rs1_cc.renode_id, rs1_cc.meta.ty , rs1_cc.meta.perm, rs1_cc.bounds.iE , rs1_cc.bounds.t , rs1_cc.bounds.tE , rs1_cc.bounds.b , rs1_cc.bounds.bE ,rs1_cc.bounds.cursor)    
+  cbound2.cap:= Cat(rs1_cc.bounds.cursor , rs1_cc.bounds.b,rs1_cc.bounds.bE,rs1_cc.bounds.tE,rs1_cc.bounds.t,rs1_cc.bounds.iE,rs1_cc.meta.perm,rs1_cc.meta.ty,rs1_cc.renode_id)
   cbound2.valid:= 1.U(1.W) 
   cbound2.tag  := 1.U(1.W)
 
-  }
+}
 class cprintModule(implicit p: Parameters) extends XSModule {
-//  class cprintModule extends Module {
-
     val src     = IO(Input(new fu_data_t))
     val cprint  = IO(Output(new cap_result_t ))
 
@@ -2672,15 +2807,15 @@ class cprintModule(implicit p: Parameters) extends XSModule {
    val rs1_c =Wire(new cap_fat_t)
 
    val cap_uncompress_cap=Module(new cap_uncompress)
-   rs1_cc.renode_id := Cat(src.cap_a(30,0))//31d
-   rs1_cc.meta.ty   := Cat(src.cap_a(33,31)) //6
-   rs1_cc.meta.perm := Cat(src.cap_a(36,34)) //6  
-   rs1_cc.bounds.iE  := Cat(src.cap_a(37)) //3    
-   rs1_cc.bounds.t   := Cat(src.cap_c(46,38)) //9
-   rs1_cc.bounds.tE  := Cat(src.cap_c(49,47)) //3
-   rs1_cc.bounds.b   := Cat(src.cap_c(60,50)) //11
-   rs1_cc.bounds.bE  := Cat(src.cap_c(63,61))//3
-   rs1_cc.bounds.cursor  := Cat(src.cap_c(127,64)) //64
+   rs1_cc.renode_id  := src.cap_a(30,0)//31d
+   rs1_cc.meta.ty    := src.cap_a(33,31) //6
+   rs1_cc.meta.perm  := src.cap_a(36,34) //6  
+   rs1_cc.bounds.iE  := src.cap_a(37) //3    
+   rs1_cc.bounds.t   := src.cap_a(46,38) //9
+   rs1_cc.bounds.tE  := src.cap_a(49,47) //3
+   rs1_cc.bounds.b   := src.cap_a(60,50) //11
+   rs1_cc.bounds.bE  := src.cap_a(63,61)//3
+   rs1_cc.bounds.cursor  := src.cap_a(127,64) //64
 
   // cap_uncompress_cap.cap_cc:=rs1_cc
   // rs1_c := cap_uncompress_cap.cap_fat
@@ -2708,28 +2843,19 @@ class cprintModule(implicit p: Parameters) extends XSModule {
   rs1_c.bounds.cursor:= src.operand_a
   rs1_c.bounds.base  := src.operand_a
   rs1_c.bounds.top   := src.operand_b
-// if
   when (src.tag_a =/=0.U) 
   {
-      // $display("%t capprint: cursor = %h, base = %h, top = %h, captype = %d, capperm = %d, renode_id = %d",
-                    // $time, rs1_c.bounds.cursor, rs1_c.bounds.base, rs1_c.bounds.top,
-                    // rs1_c.meta.ty, rs1_c.meta.perm, rs1_c.renode_id);
   cprint.cap  := 0.U(128.W) 
   cprint.tag  := 0.U(1.W)
   cprint.valid:= 0.U(1.W)
   }
-  .otherwise//else
-  {
-            // $display("%t capprint: scalar = %x", $time, fu_data_cur.operand_a);
-  }
+
   cprint.cap  := 0.U(128.W) 
   cprint.tag  := 0.U(1.W)
   cprint.valid:= 0.U(1.W)
 
-  }
+}
 class cregprintModule(implicit p: Parameters) extends XSModule {
-//  class cregprintModule  extends Module {
-
   val src = IO(Input(new fu_data_t))
   val cregprint  = IO(Output(new cap_result_t )) 
 
@@ -2741,35 +2867,25 @@ class cregprintModule(implicit p: Parameters) extends XSModule {
 }
 
 class getrandModule(implicit p: Parameters) extends XSModule {
-//  class getrandModule extends Module {
-    val src = IO(Input(new fu_data_t))
-    val getrand  = IO(Output(new cap_result_t ))
+  val src      = IO(Input(new fu_data_t))
+  val getrand  = IO(Output(new cap_result_t ))
 
   getrand.cap  := 0.U(128.W) 
   getrand.tag  := 0.U(1.W)
   getrand.valid:= 0.U(1.W)
 
-  }
+}
 class tagsetModule(implicit p: Parameters) extends XSModule {
-//  class tagsetModule  extends Module {
-  // val io = IO(new Bundle() {
-  //   // val src = Input(UInt(XLEN.W))
-  //   // val tagset = Output(UInt(XLEN.W))
-  // })
-    val src = IO(Input(new fu_data_t))
-    val tagset  = IO(Output(new cap_result_t ))
+  val src     = IO(Input(new fu_data_t))
+  val tagset  = IO(Output(new cap_result_t ))
 
   tagset.cap  := 0.U(128.W) 
   tagset.tag  := 0.U(1.W)
   tagset.valid:= 0.U(1.W)
 
-  }
-   class taggetModule(implicit p: Parameters) extends XSModule {
-//  class taggetModule extends Module {
-  // val io = IO(new Bundle() {
-  //   // val src = Input(UInt(XLEN.W))
-  //   // val tagget = Output(UInt(XLEN.W))
-  // })
+}
+class taggetModule(implicit p: Parameters) extends XSModule {
+
     val src = IO(Input(new fu_data_t))
     val tagget  = IO(Output(new cap_result_t ))
 
@@ -2779,7 +2895,6 @@ class tagsetModule(implicit p: Parameters) extends XSModule {
 }
 
 class AddModule(implicit p: Parameters) extends XSModule {
-// class AddModule extends Module {
   val io = IO(new Bundle() {
     val src = Vec(2, Input(UInt(XLEN.W)))
     val srcw = Input(UInt((XLEN/2).W))
@@ -2789,29 +2904,20 @@ class AddModule(implicit p: Parameters) extends XSModule {
   io.add := io.src(0) + io.src(1)
   // TODO: why this extra adder?
   io.addw := io.srcw + io.src(1)(31,0)
-  // Debug Info//mlabaf
-
-//  printf("instruction in alu is addition print")  
-  
+  // Debug Info//mlabaf  
   XSDebug("instruction is additon XSD=%b\n",io.src(0))
   
 }
 
 class SubModule(implicit p: Parameters) extends XSModule {
-// class SubModule extends Module {
   val io = IO(new Bundle() {
     val src = Vec(2, Input(UInt(XLEN.W)))
     val sub = Output(UInt((XLEN+1).W))
   })
   io.sub := (io.src(0) +& (~io.src(1)).asUInt()) + 1.U
-
-  // Debug Info//mlabaf
- // XSDebug("instruction is subtraction=%b\n",io.src(0))
- // printf("instruction in alu is subtraction")
  }
 
 class LeftShiftModule(implicit p: Parameters) extends XSModule {
-// class LeftShiftModule extends Module {
   val io = IO(new Bundle() {
     val shamt = Input(UInt(6.W))
     val revShamt = Input(UInt(6.W))
@@ -2824,7 +2930,6 @@ class LeftShiftModule(implicit p: Parameters) extends XSModule {
 }
 
 class LeftShiftWordModule(implicit p: Parameters) extends XSModule {
-// class LeftShiftWordModule extends Module {
   val io = IO(new Bundle() {
     val shamt = Input(UInt(5.W))
     val revShamt = Input(UInt(5.W))
@@ -2837,7 +2942,6 @@ class LeftShiftWordModule(implicit p: Parameters) extends XSModule {
 }
 
 class RightShiftModule(implicit p: Parameters) extends XSModule {
-// class RightShiftModule extends Module {
     val io = IO(new Bundle() {
     val shamt = Input(UInt(6.W))
     val revShamt = Input(UInt(6.W))
@@ -2851,7 +2955,6 @@ class RightShiftModule(implicit p: Parameters) extends XSModule {
 }
 
 class RightShiftWordModule(implicit p: Parameters) extends XSModule {
-// class RightShiftWordModule extends Module {
   val io = IO(new Bundle() {
     val shamt = Input(UInt(5.W))
     val revShamt = Input(UInt(5.W))
@@ -2867,7 +2970,6 @@ class RightShiftWordModule(implicit p: Parameters) extends XSModule {
 
 
 class MiscResultSelect(implicit p: Parameters) extends XSModule {
-//class MiscResultSelect extends Module {
   val io = IO(new Bundle() {
     val func = Input(UInt(6.W))
     val and, or, xor, orcb, orh48, sextb, packh, sexth, packw, revb, rev8, pack = Input(UInt(XLEN.W))
@@ -2899,7 +3001,6 @@ class MiscResultSelect(implicit p: Parameters) extends XSModule {
 }
 
  class ShiftResultSelect(implicit p: Parameters) extends XSModule {
-//class ShiftResultSelect extends Module {
   val io = IO(new Bundle() {
     val func = Input(UInt(4.W))
     val sll, srl, sra, rol, ror, bclr, bset, binv, bext = Input(UInt(XLEN.W))
@@ -2925,7 +3026,6 @@ class MiscResultSelect(implicit p: Parameters) extends XSModule {
 }
 
 class WordResultSelect(implicit p: Parameters) extends XSModule {
-//class WordResultSelect extends Module {
   val io = IO(new Bundle() {
     val func = Input(UInt())
     val sllw, srlw, sraw, rolw, rorw, addw, subw = Input(UInt((XLEN/2).W))
@@ -2940,34 +3040,23 @@ class WordResultSelect(implicit p: Parameters) extends XSModule {
 }
 
 class capResultSelect(implicit p: Parameters) extends XSModule {
-//class capResultSelect extends Module {
   val io = IO(new Bundle() {
     val func = Input(UInt())
 
   })
-
-    // val   crevoke,cshrink,ctighten,cdelin,clcc,cscc,csplit,cseal,cmrev,cinit,cmovc,cdrop,ccincoffset,
-    //       ccall,creturn,ccjalr,ccbnz,cccsrrw,ccapenter,ccincoffsetim,cshrinkto,ccreate,ctype,
-    //       cnode,cperm,cbound,cprint,cregprint,getrand,tagset,tagget= Input(UInt((XLEN).W))    
-    
+ 
     val   crevoke,cshrink,ctighten,cdelin,clcc,cscc,csplit,cseal,cmrev,cinit,cmovc,cdrop,ccincoffset,
           ccall,creturn,ccjalr,ccbnz,cccsrrw,ccapenter,ccincoffsetim,cshrinkto,ccreate,ctype,
           cnode,cperm,cbound,cprint,cregprint,getrand,tagset,tagget= IO(Input(new cap_result_t))
     // val capRes = Output(UInt(XLEN.W))
     val capRes = IO(Output(new cap_result_t))
 
-//val res
   capRes.cap        := 0.U
   capRes.tag        := 0.U 
   capRes.valid      := 0.U
 
   switch(io.func)
   {
- // is (0.U){res:=io.crevoke}
- // is (1.U){res:=io.cshrink}
- // is (3.U){res:=io.cdelin}
- // is (4.U){res:=io.clcc}
-
   is (0.U)
    {
     capRes.cap:=crevoke.cap
@@ -3135,33 +3224,7 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   XSDebug("instruction in alu capstone_select =%b\n",io.func)
 
 }
-
-
-
-// //capstone//mlabaf
-// // class AluResSel(implicit p: Parameters) extends XSModule {
-// class AluResSel extends Module {
-//   val io = IO(new Bundle() {
-//   //  val func = Input(UInt(3.W))
-//     val func = Input(UInt(4.W))
-//   //  val addRes, shiftRes, miscRes, compareRes, wordRes = Input(UInt(XLEN.W))
-//     val capRes,addRes, shiftRes, miscRes, compareRes, wordRes = Input(UInt(XLEN.W))
-//     val aluRes = Output(UInt(XLEN.W))
-//   })
-
-//   //val res = Mux(io.func(2, 1) === 0.U, Mux(io.func(0), io.wordRes, io.shiftRes),
-//   //          Mux(!io.func(2), Mux(io.func(0), io.compareRes, io.addRes), io.miscRes))
-//   val res = Mux(io.func(3),io.capRes,Mux(io.func(2, 1) === 0.U, Mux(io.func(0), io.wordRes, io.shiftRes),
-//             Mux(!io.func(2), Mux(io.func(0), io.compareRes, io.addRes), io.miscRes)))            
-//   io.aluRes := res
-
-//   //printf("instruction in aluresselect is capstone print")  
-//   //XSDebug("instruction is capstone aluresselect=%b\n",io.func)
-// //  Debug("instruction is capstone aluresselect=%b\n",io.func)
-  
-// }
  class AluResSel(implicit p: Parameters) extends XSModule {
-//class AluResSel extends Module {
   val io = IO(new Bundle() {
   val func = Input(UInt(3.W))
    // val func = Input(UInt(4.W))
@@ -3183,7 +3246,6 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
 
 //capstone//mlabaf
  class AluCapResSel(implicit p: Parameters) extends XSModule {
-//class AluCapResSel extends Module {
   val io = IO(new Bundle() {
   //  val func = Input(UInt(3.W))
     // val func = Input(UInt(4.W))
@@ -3196,14 +3258,6 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
     val ExResTag = Output(UInt(1.W))
     
   })
-  //  val capRes = IO(Input (new cap_result_t))
-
-
-  //val res = Mux(io.func(2, 1) === 0.U, Mux(io.func(0), io.wordRes, io.shiftRes),
-  //          Mux(!io.func(2), Mux(io.func(0), io.compareRes, io.addRes), io.miscRes))
-  // val Res      = Mux(io.func(3),io.capRes.cap,io.AluRes)
-  // val ResValid = Mux(io.func(3),io.capRes.valid,0.U)
-  // val ResTag   = Mux(io.func(3),io.capRes.tag,0.U)
 
   val Res      = Mux(io.func(7),io.capRes.cap,io.AluRes)
   val ResValid = Mux(io.func(7),io.capRes.valid,0.U)
@@ -3213,10 +3267,7 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   io.ExResValid := ResValid
   io.ExResTag := ResTag
 
-  //printf("instruction in aluresselect is capstone print")  
- // XSDebug("instruction is capstone aluresselect=%b\n",io.func)
- XSDebug("AluCapResSel =%b\n",io.func)
-//  Debug("instruction is capstone aluresselect=%b\n",io.func)
+  XSDebug("AluCapResSel =%b\n",io.func)
   
 }
 
@@ -3254,7 +3305,7 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
 
 
 //Capstone//mlabaf
- class CapExeModule(implicit p: Parameters) extends XSModule {
+class CapExeModule(implicit p: Parameters) extends XSModule {
   val io = IO(new Bundle() {
   val func      = Input(FuOpType())
   val operand_a =Input( UInt (XLEN.W))
@@ -3271,7 +3322,7 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   val rs1       =Input( UInt (5.W))
   val rs2       =Input( UInt (5.W))  
   val trans_id  =Input( UInt (TRANS_ID_BITS.W))  
-//////////////////////////////////////////////////
+ //////////////////////////////////////////////////
 
  })  
 
@@ -3280,7 +3331,7 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
 
 
 
-//  def is_full   = UInt (1.W)
+ //  def is_full   = UInt (1.W)
  def is_return = UInt (1.W) // if this is return, ra is overwritten
  def dom_base  = UInt (XLEN.W)
  def out_dom_base = UInt (XLEN.W)
@@ -3333,7 +3384,7 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   src.imm   := io.imm    
   src.cap_a := io.cap_a   
   src.cap_b := io.cap_b   
-  src.cap_c := io.cap_b   
+  src.cap_c := io.cap_c   
   src.tag_a := io.tag_a   
   src.tag_b := io.tag_b   
   src.tag_c := io.tag_c    
@@ -3342,15 +3393,16 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   src.rs1   := io.rs1   
   src.rs2   := io.rs2 
   src.trans_id   := io.trans_id  
-//////////////////////output initial value//////////////////
+ //////////////////////output initial value//////////////////
 
-//////////////////needed node value///////////////
+ //////////////////needed node value///////////////
   val node_alloc_state_d   = Reg(UInt(4.W))
   val node_alloc_valid_o   = Reg(UInt(1.W)) 
   val node_alloc_ready_i   = Reg(UInt(1.W))
   val node_alloc_state_q   = RegInit(0.U(4.W))
- 
-
+  val node_alloc_resp_valid_i = Reg(UInt(31.W))//cap_renod_id_t
+  val node_alloc_node_id_i    = Reg(UInt(31.W))//cap_renod_id_t
+  
   val revnode_id       = RegInit(0.U(31.W))//Wire( cap_renode_id_t)
   val node_alloc_node_id_cur = RegInit(0.U(31.W))//Reg( cap_renode_id_t)
   val mut_ty           = Reg(UInt(4.W))
@@ -3377,9 +3429,9 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   val node_query_resp_result_d   = RegInit(0.U(1.W))
   val node_query_resp_received_d = RegInit(0.U(1.W))
   val node_query_resp_result_q   = RegInit(0.U(1.W))
-///////////////////////end node variable/////////// 
+ ///////////////////////end node variable/////////// 
 
-//////////////////////Capstone_unit variable/////////////////////
+ //////////////////////Capstone_unit variable/////////////////////
   val node_alloc_node_id_q, node_alloc_node_id_d = RegInit(0.U(31.W)) //cap_renode_id_t
 
   node_alloc_node_id_cur := Mux((node_alloc_state_q === mut_t.NODE_ALLOC_RECEIVED ), node_alloc_node_id_q , CapExe_ins.node_alloc_node_id_i)
@@ -3410,45 +3462,14 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   fu_data_last_q := fu_data_last_n
 
   CapExe_ins.capstone_valid_o := valid_cur
-/////////////////////////////////////////////////////////////////////
-  // val exe_node_query_ins    = Wire(new send_node_query_bundle)
-  // val exe_node_mut_ins      = Wire(new send_node_mut_bundle) 
-  // val exe_node_alloc_ins    = Wire(new send_node_alloc_bundle) 
-  
-  // exe_node_query_ins.revnode_id                 := revnode_id
-  // exe_node_query_ins.node_query_sent_q          := node_query_sent_q
-  // exe_node_query_ins.node_query_ready_i         := node_query_ready_i 
-  // exe_node_query_ins.node_query_resp_valid_i    := node_query_resp_valid_i 
-  // exe_node_query_ins.node_query_resp_received_q := node_query_resp_received_q 
-  // exe_node_query_ins.synchronous                := synchronous
-  // exe_node_query_ins.node_query_resp_i          := node_query_resp_i 
-
-  // exe_node_query_ins.node_query_sent_d          := node_query_sent_d
-  // exe_node_query_ins.node_query_valid_o         := node_query_valid_o 
-  // exe_node_query_ins.rd_result_o                := rd_result_o  
-  // exe_node_query_ins.node_query_o               := node_query_o      
-  // exe_node_query_ins.node_query_resp_result_d   := node_query_resp_result_d
-  // exe_node_query_ins.node_query_resp_received_d := node_query_resp_received_d 
-  // exe_node_query_ins.node_query_resp_result_q   := node_query_resp_result_q
- 
-  //   // val node_mut_valid_o = Output(UInt(1.W))
-  //   // val node_mut_o       = Output(new node_mut_t)   
-
-  // exe_node_mut_ins.revnode_id       := revnode_id
-  // exe_node_mut_ins.node_alloc_node_id_cur := node_alloc_node_id_cur
-  // exe_node_mut_ins.mut_ty           := mut_ty 
-  // exe_node_mut_ins.have_alloc       := have_alloc 
-  // exe_node_mut_ins.node_mut_valid_o := node_mut_valid_o
-  // // exe_node_mut_ins.node_mut_o       := node_mut_o 
-  // exe_node_mut_ins.node_mut_o.node_id  := node_mut_o.node_id            
-  // exe_node_mut_ins.node_mut_o.node_op  := node_mut_o.node_op            
-  // exe_node_mut_ins.node_mut_o.alloc    := node_mut_o.alloc            
-  // exe_node_mut_ins.node_mut_o.new_node_id := node_mut_o.new_node_id     
-
-  // exe_node_alloc_ins.node_alloc_state_d   := node_alloc_state_d
-  // exe_node_alloc_ins.node_alloc_valid_o   := node_alloc_valid_o
-  // exe_node_alloc_ins.node_alloc_ready_i   := node_alloc_ready_i
-  // exe_node_alloc_ins.node_alloc_state_q   := node_alloc_state_q
+ /////////////////////////////////////////////////////////////////////
+  node_query_ready_i         := CapExe_ins.node_query_ready_i 
+  node_query_resp_valid_i    := CapExe_ins.node_query_resp_valid_i 
+  node_query_resp_i          := CapExe_ins.node_query_resp_i 
+
+  node_alloc_resp_valid_i   := CapExe_ins.node_alloc_resp_valid_i
+  node_alloc_ready_i        := CapExe_ins.node_alloc_ready_i
+  node_alloc_node_id_i      := CapExe_ins.node_alloc_node_id_i
   
   
   //////////////////////////////////////////////////////////////////
@@ -3523,9 +3544,10 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   csplitModule.send_node_query_ins.synchronous                := synchronous
   csplitModule.send_node_query_ins.node_query_resp_i          := node_query_resp_i
   //assign input alloc
-  csplitModule.send_node_alloc_ins.node_alloc_ready_i   := node_alloc_ready_i
-  csplitModule.send_node_alloc_ins.node_alloc_state_q   := node_alloc_state_q 
-
+  csplitModule.send_node_alloc_ins.node_alloc_ready_i      := node_alloc_ready_i
+  csplitModule.send_node_alloc_ins.node_alloc_state_q      := node_alloc_state_q 
+  csplitModule.send_node_alloc_ins.node_alloc_resp_valid_i := node_alloc_resp_valid_i
+  csplitModule.send_node_alloc_ins.node_alloc_node_id_i    := node_alloc_node_id_i
   val csealModule   = Module(new csealModule)
   csealModule.src :=  src
   val cseal =  csealModule.cseal 
@@ -3547,8 +3569,10 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   cmrevModule.send_node_query_ins.synchronous                := synchronous
   cmrevModule.send_node_query_ins.node_query_resp_i          := node_query_resp_i
   //assign input alloc
-  cmrevModule.send_node_alloc_ins.node_alloc_ready_i   := node_alloc_ready_i
-  cmrevModule.send_node_alloc_ins.node_alloc_state_q   := node_alloc_state_q 
+  cmrevModule.send_node_alloc_ins.node_alloc_ready_i      := node_alloc_ready_i
+  cmrevModule.send_node_alloc_ins.node_alloc_state_q      := node_alloc_state_q 
+  cmrevModule.send_node_alloc_ins.node_alloc_resp_valid_i := node_alloc_resp_valid_i
+  cmrevModule.send_node_alloc_ins.node_alloc_node_id_i    := node_alloc_node_id_i
 
   val cinitModule   = Module(new cinitModule)
   cinitModule.src :=  src
@@ -3702,7 +3726,7 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   // val capRes = capResSel.io.capRes
    capRes := capResSel.capRes
 
-//select node result
+ //select node result
   switch(io.func(6, 0))
   {
   is (0.U)
@@ -3784,6 +3808,8 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
     //output from alloc
     node_alloc_state_d := csplitModule.send_node_alloc_ins.node_alloc_state_d   
     node_alloc_valid_o := csplitModule.send_node_alloc_ins.node_alloc_valid_o
+    node_alloc_node_id_d := csplitModule.send_node_alloc_ins.node_alloc_node_id_d
+
     //output from query    
     node_query_sent_d          := csplitModule.send_node_query_ins.node_query_sent_d
     node_query_valid_o         := csplitModule.send_node_query_ins.node_query_valid_o
@@ -3810,7 +3836,9 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
    node_mut_o.new_node_id  := cmrevModule.send_node_mut_ins.node_mut_o.new_node_id 
   //output from alloc
    node_alloc_state_d := cmrevModule.send_node_alloc_ins.node_alloc_state_d   
-   node_alloc_valid_o := cmrevModule.send_node_alloc_ins.node_alloc_valid_o   
+   node_alloc_valid_o := cmrevModule.send_node_alloc_ins.node_alloc_valid_o
+   node_alloc_node_id_d := cmrevModule.send_node_alloc_ins.node_alloc_node_id_d
+   
     //output from query    
     node_query_sent_d          := cmrevModule.send_node_query_ins.node_query_sent_d
     node_query_valid_o         := cmrevModule.send_node_query_ins.node_query_valid_o
@@ -3907,19 +3935,18 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
     printf( " f node_mut_o.node_op  %b\n",node_mut_o.node_op)
     printf( " f CapExe_ins.node_mut_o.node_op %b\n",CapExe_ins.node_mut_o.node_op)
 
- }
+}
 
 
  //class AluDataModule ( typ: cap_result_t)(implicit p: Parameters) extends XSModule {
-  class AluDataModule (implicit p: Parameters) extends XSModule {
- //class AluDataModule extends Module {
-  val io = IO(new Bundle() {
+class AluDataModule (implicit p: Parameters) extends XSModule {
+   val io = IO(new Bundle() {
     val src = Vec(2, Input(UInt(XLEN.W)))
     val func = Input(FuOpType())
     val pred_taken, isBranch = Input(Bool())
     val result = Output(UInt(XLEN.W))
     val taken, mispredict = Output(Bool())
-  })   
+   })   
 
 
   val (src1, src2, func) = (io.src(0), io.src(1), io.func)
@@ -4106,8 +4133,6 @@ class capResultSelect(implicit p: Parameters) extends XSModule {
   io.taken := taken
   io.mispredict := (io.pred_taken ^ taken) && io.isBranch
 
- // printf("instruction code in alu what")  
- // XSDebug("aluResSel in AluDataModule=%b\n",aluResSel.io.func)
 }
 
 
@@ -4130,10 +4155,10 @@ class Alu(implicit p: Parameters) extends FUWithRedirect {
   CapEModule.io.operand_a := io.in.bits.operand_a 
   CapEModule.io.operand_b := io.in.bits.operand_b
   CapEModule.io.imm       := io.in.bits.imm
-  //CapEModule.io.cap_a     := io.in.bits.cap_a 
+  CapEModule.io.cap_a     := io.in.bits.cap_a 
   CapEModule.io.cap_b     := io.in.bits.cap_b 
   CapEModule.io.cap_c     := io.in.bits.cap_c 
- // CapEModule.io.tag_a     := io.in.bits.tag_a
+  CapEModule.io.tag_a     := io.in.bits.tag_a
   CapEModule.io.tag_b     := io.in.bits.tag_b
   CapEModule.io.tag_c     := io.in.bits.tag_c
   CapEModule.io.valid     := io.in.bits.valid
@@ -4146,12 +4171,6 @@ class Alu(implicit p: Parameters) extends FUWithRedirect {
   CapEModule.CapExe_ins.pc_i                    := io.in.bits.pc_i //issue_stage// PC of instruction
   CapEModule.CapExe_ins.capstone_valid_i        := io.in.bits.capstone_valid_i//issue_stage
   CapEModule.CapExe_ins.cih_i                   := io.in.bits.cih_i //csr      
-  // CapEModule.CapExe_ins.node_query_ready_i      := io.in.bits.node_query_ready_i  
-  // CapEModule.CapExe_ins.node_query_resp_valid_i := io.in.bits.node_query_resp_valid_i
-  // CapEModule.CapExe_ins.node_query_resp_i       := io.in.bits.node_query_resp_i
-  // CapEModule.CapExe_ins.node_alloc_ready_i      := io.in.bits.node_alloc_ready_i 
-  // CapEModule.CapExe_ins.node_alloc_resp_valid_i := io.in.bits.node_alloc_resp_valid_i  
-  // CapEModule.CapExe_ins.node_alloc_node_id_i    := io.in.bits.node_alloc_node_id_i//cap_revnode_id_t)//?
 
   io.out.bits.ex_o                := CapEModule.CapExe_ins.ex_o                 
   io.out.bits.cms_result_o        := CapEModule.CapExe_ins.cms_result_o 
@@ -4160,9 +4179,7 @@ class Alu(implicit p: Parameters) extends FUWithRedirect {
   io.out.bits.capstone_trans_id_o := CapEModule.CapExe_ins.capstone_trans_id_o   
   io.out.bits.dom_switch_valid_o  := CapEModule.CapExe_ins.dom_switch_valid_o                      
   io.out.bits.dom_switch_req_o    := CapEModule.CapExe_ins.dom_switch_req_o                 
-  // io.out.bits.node_query_valid_o  := CapEModule.CapExe_ins.node_query_valid_o      
-  // io.out.bits.node_query_o        := CapEModule.CapExe_ins.node_query_o           
-  // io.out.bits.node_alloc_valid_o  := CapEModule.CapExe_ins.node_alloc_valid_o     
+  
   // scoreboard
   io.out.bits.node_mut_valid_o    := CapEModule.CapExe_ins.node_mut_valid_o         
   io.out.bits.node_mut_o.node_id  := CapEModule.CapExe_ins.node_mut_o.node_id            
@@ -4174,11 +4191,7 @@ class Alu(implicit p: Parameters) extends FUWithRedirect {
   val mock_node_unit_ins = Module(new mock_node_unit)
 
   mock_node_unit_ins.io.flush_i := io.in.bits.flush_i
-      // query interface (asynchronous)
-   mock_node_unit_ins.io.query_valid_i(2) := CapEModule.CapExe_ins.node_query_valid_o
-   mock_node_unit_ins.io.query_i(2)       <> CapEModule.CapExe_ins.node_query_o//node_query_t
- 
-//for test
+ //temporarily
    mock_node_unit_ins.io.query_valid_i(0) := 0.U
    mock_node_unit_ins.io.query_i(0).synchronous    := 0.U
    mock_node_unit_ins.io.query_i(0).trans_id       := 0.U
@@ -4186,15 +4199,14 @@ class Alu(implicit p: Parameters) extends FUWithRedirect {
    mock_node_unit_ins.io.query_valid_i(1) := 0.U
    mock_node_unit_ins.io.query_i(1).synchronous    := 0.U
    mock_node_unit_ins.io.query_i(1).trans_id       := 0.U
-   mock_node_unit_ins.io.query_i(1).node_id        := 0.U
-
-
+   mock_node_unit_ins.io.query_i(1).node_id        := 0.U     
+  // query interface (asynchronous)
+   mock_node_unit_ins.io.query_valid_i(2) := CapEModule.CapExe_ins.node_query_valid_o
+   mock_node_unit_ins.io.query_i(2)       <> CapEModule.CapExe_ins.node_query_o//node_query_t
    // allocation interface
    mock_node_unit_ins.io.alloc_valid_i := CapEModule.CapExe_ins.node_alloc_valid_o 
    // mutation interface
    mock_node_unit_ins.io.mut_valid_i   := CapEModule.CapExe_ins.node_mut_valid_o//1.U//commit_stage
-  //                                   :=   mock_node_unit_ins.io.mut_ready_o//commit_stage
-  //  mock_node_unit_ins.io.mut_i         := 0.U//commit_stage
    mock_node_unit_ins.io.mut_i.node_id       := CapEModule.CapExe_ins.node_mut_o.node_id //0.U//commit_stage
    mock_node_unit_ins.io.mut_i.node_op       := CapEModule.CapExe_ins.node_mut_o.node_op//0.U//commit_stage
    mock_node_unit_ins.io.mut_i.alloc         := CapEModule.CapExe_ins.node_mut_o.alloc//0.U//commit_stage
@@ -4215,12 +4227,8 @@ class Alu(implicit p: Parameters) extends FUWithRedirect {
    CapEModule.CapExe_ins.node_alloc_ready_i      := mock_node_unit_ins.io.alloc_ready_o
    CapEModule.CapExe_ins.node_alloc_resp_valid_i := mock_node_unit_ins.io.alloc_valid_o
 
-//////////////////////////////////////////////
-  //for test
-  // CapEModule.io.cap_a     := Cat(31.U(93.U), cap_type_t.CAP_TYPE_REVOKE ,29.U(31.W))
-  CapEModule.io.cap_a     := Cat(31.U(93.U), cap_type_t.CAP_TYPE_LINEAR ,29.U(31.W))
-  CapEModule.io.tag_a     := 0.U
- //end test 
+ //////////////////////////////////////////////ALU_Capability_selector//////////////////////////////////////
+
 
   val ResSel        = Module(new AluCapResSel)
   ResSel.io.func   := io.in.bits.uop.ctrl.fuOpType
@@ -4240,138 +4248,244 @@ class Alu(implicit p: Parameters) extends FUWithRedirect {
   io.in.ready  := io.out.ready
   io.out.valid := io.in.valid
   io.out.bits.uop <> io.in.bits.uop
-//  io.out.bits.data := dataModule.io.result
+ //  io.out.bits.data := dataModule.io.result
   io.out.bits.data := ResSel.io.ExRes
   io.out.bits.tag  := ResSel.io.ExResTag
   io.out.bits.valid:= ResSel.io.ExResValid
 
-when(dataModule.io.func===128.U)
-{
-  printf("instruction code in alu is: crevoke")
-}
-.elsewhen(dataModule.io.func===134.U)
- { 
-  printf("instruction code in alu is: csplit")
+ ////////////////////////////////////////////for test// cpmpression and uncompression function///////////////////////////
+
+
+ when(dataModule.io.func===128.U)
+ {
+   printf("instruction code in alu is: crevoke")
  }
-.elsewhen(dataModule.io.func===139.U)
-  {
-    printf("instruction code in alu is: cdrop")
+ .elsewhen(dataModule.io.func===129.U)
+  { 
+   printf("instruction code in alu is: shrink")
   }
-.elsewhen(dataModule.io.func===131.U)
-  {
-    printf("instruction code in alu is: delin")
+ .elsewhen(dataModule.io.func===130.U)
+   {
+     printf("instruction code in alu is: tighten")
+   }
+ .elsewhen(dataModule.io.func===131.U)
+   {
+     printf("instruction code in alu is: delin")
+   }
+ .elsewhen(dataModule.io.func===132.U)
+  { 
+   printf("instruction code in alu is: lcc")
   }
-
-
-  // switch(dataModule.io.func)
-  // {
-  //   is (64.U){ printf("instruction code in alu is: and")}
-  //   is (64.U){ printf("instruction code in alu is: add")}
-  //   is (128.U){ printf("instruction code in alu is: crevoke")}
-  //   is (129.U){ printf("instruction code in alu is: cshrink")}
-  //   is (130.U){ printf("instruction code in alu is: ctighten")}
-  //   is (131.U){ printf("instruction code in alu is: cdelin")}
-  //   is (132.U){ printf("instruction code in alu is: clcc")}
-  //   is (133.U){ printf("instruction code in alu is: cscc")}
-  //   is (134.U){ printf("instruction code in alu is: csplit")}
-  //   is (135.U){ printf("instruction code in alu is: cseal")}
-  //   is (136.U){ printf("instruction code in alu is: cmrev")}
-  //   is (137.U){ printf("instruction code in alu is: cinit")}
-  //   is (138.U){ printf("instruction code in alu is: cmovc")}
-  //   is (139.U){ printf("instruction code in alu is: cdrop")}        
-  //   is (140.U){ printf("instruction code in alu is: ccincoffset")}    
-  //   is (141.U){ printf("instruction code in alu is: ccall")}    
-  //   is (142.U){ printf("instruction code in alu is: creturn")}    
-  //   is (143.U){ printf("instruction code in alu is: ccjalr")}    
-  //   is (144.U){ printf("instruction code in alu is: ccbnz")}    
-  //   is (145.U){ printf("instruction code in alu is: cccsrrw")}    
-  //   is (146.U){ printf("instruction code in alu is: ccapenter")}
-  //   is (147.U){ printf("instruction code in alu is: ccincoffsetim")}    
-  //   is (148.U){ printf("instruction code in alu is: cshrinkto")}    
-  //   is (149.U){ printf("instruction code in alu is: ccreate")}      
-  //   is (150.U){ printf("instruction code in alu is: ctype")}      
-  //   is (151.U){ printf("instruction code in alu is: cnode")}    
-  //   is (152.U){ printf("instruction code in alu is: cperm")}    
-  //   is (153.U){ printf("instruction code in alu is: cbound")}    
-  //   is (154.U){ printf("instruction code in alu is: cprint")}    
-  //   is (155.U){ printf("instruction code in alu is: cregprint")}    
-  //   is (156.U){ printf("instruction code in alu is: getrand")}    
-  //   is (157.U){ printf("instruction code in alu is: tagset")}    
-  //   is (158.U){ printf("instruction code in alu is: tagget")}    
-  //  // is (159.U){ printf("instruction code in alu is: sdd")}    
-      
-  // }
-  XSDebug("instruction in alu class1=%b\n",dataModule.io.func)
-  XSDebug("instruction in alu class2=%b\n",io.in.bits.uop.ctrl.fuOpType)
-
-////////////////////////////////////////////for test// cpmpression and uncompression function///////////////////////////
-   val rs1_cc = Reg(new cap_cc_t)
-   val rs1_c  = Reg(new cap_fat_t) 
-   val cap_uncompress_cap = Module(new cap_uncompress)
-   val cap_compress_cap   = Module(new cap_compress)
-   val rs2_c  = Reg(new cap_fat_t) 
-   rs1_c.bounds.cursor:=100230256.U//100231256.U//807661056.U//"h00df000000121400".U//1400.U//
-   rs1_c.bounds.base  :=100230132.U//100230132.U//807660032.U//"h00df000000121000".U//1000.U//
-   rs1_c.bounds.top   :=100230328.U//100234228.U//807664128.U//"h00df000000122000".U//2000.U//
-           
-   rs1_c.reg_id:= 3.U
-   rs1_c.async:= 1.U
-   rs1_c.padding:=0.U
-   rs1_c.meta.ty:= cap_type_t.CAP_TYPE_REVOKE
-   rs1_c.meta.perm:= cap_perm_t.CAP_PERM_RWX
+ .elsewhen(dataModule.io.func===133.U)
+   {
+     printf("instruction code in alu is: scc")
+   }
+ .elsewhen(dataModule.io.func===134.U)
+   {
+     printf("instruction code in alu is: split")
+   }
+ .elsewhen(dataModule.io.func===135.U)
+  { 
+   printf("instruction code in alu is: seal")
+  }
+ .elsewhen(dataModule.io.func===136.U)
+   {
+     printf("instruction code in alu is: mrev")
+   }
+ .elsewhen(dataModule.io.func===137.U)
+   {
+     printf("instruction code in alu is: cinit")
+   }
+ .elsewhen(dataModule.io.func===138.U)
+  { 
+   printf("instruction code in alu is: mov")
+  }
+ .elsewhen(dataModule.io.func===139.U)
+   {
+     printf("instruction code in alu is: drop")
+   }
+ .elsewhen(dataModule.io.func===140.U)
+   {
+     printf("instruction code in alu is: ccincoffset")
+   }
+ .elsewhen(dataModule.io.func===141.U)
+  { 
+   printf("instruction code in alu is: call")
+  }
+ .elsewhen(dataModule.io.func===142.U)
+   {
+     printf("instruction code in alu is: return")
+   }
+ .elsewhen(dataModule.io.func===143.U)
+   {
+     printf("instruction code in alu is: ccjalr")
+   }
+ .elsewhen(dataModule.io.func===144.U)
+  { 
+   printf("instruction code in alu is: bnz")
+  }
+ .elsewhen(dataModule.io.func===145.U)
+   {
+     printf("instruction code in alu is: cccsrrw")
+   }
+ .elsewhen(dataModule.io.func===146.U)
+   {
+     printf("instruction code in alu is: ccapenter")
+   }    
+ .elsewhen(dataModule.io.func===147.U)
+  { 
+   printf("instruction code in alu is: ccincoffsetim")
+  }
+ .elsewhen(dataModule.io.func===148.U)
+   {
+     printf("instruction code in alu is: cshrinkto")
+   }
+ 
+ 
+   // switch(dataModule.io.func)
+   // {
+   //   is (64.U){ printf("instruction code in alu is: and")}
+   //   is (64.U){ printf("instruction code in alu is: add")}
+   //   is (128.U){ printf("instruction code in alu is: crevoke")}
+   //   is (129.U){ printf("instruction code in alu is: cshrink")}
+   //   is (130.U){ printf("instruction code in alu is: ctighten")}
+   //   is (131.U){ printf("instruction code in alu is: cdelin")}
+   //   is (132.U){ printf("instruction code in alu is: clcc")}
+   //   is (133.U){ printf("instruction code in alu is: cscc")}
+   //   is (134.U){ printf("instruction code in alu is: csplit")}
+   //   is (135.U){ printf("instruction code in alu is: cseal")}
+   //   is (136.U){ printf("instruction code in alu is: cmrev")}
+   //   is (137.U){ printf("instruction code in alu is: cinit")}
+   //   is (138.U){ printf("instruction code in alu is: cmovc")}
+   //   is (139.U){ printf("instruction code in alu is: cdrop")}        
+   //   is (140.U){ printf("instruction code in alu is: ccincoffset")}    
+   //   is (141.U){ printf("instruction code in alu is: ccall")}    
+   //   is (142.U){ printf("instruction code in alu is: creturn")}    
+   //   is (143.U){ printf("instruction code in alu is: ccjalr")}    
+   //   is (144.U){ printf("instruction code in alu is: ccbnz")}    
+   //   is (145.U){ printf("instruction code in alu is: cccsrrw")}    
+   //   is (146.U){ printf("instruction code in alu is: ccapenter")}
+   //   is (147.U){ printf("instruction code in alu is: ccincoffsetim")}    
+   //   is (148.U){ printf("instruction code in alu is: cshrinkto")}    
+   //   is (149.U){ printf("instruction code in alu is: ccreate")}      
+   //   is (150.U){ printf("instruction code in alu is: ctype")}      
+   //   is (151.U){ printf("instruction code in alu is: cnode")}    
+   //   is (152.U){ printf("instruction code in alu is: cperm")}    
+   //   is (153.U){ printf("instruction code in alu is: cbound")}    
+   //   is (154.U){ printf("instruction code in alu is: cprint")}    
+   //   is (155.U){ printf("instruction code in alu is: cregprint")}    
+   //   is (156.U){ printf("instruction code in alu is: getrand")}    
+   //   is (157.U){ printf("instruction code in alu is: tagset")}    
+   //   is (158.U){ printf("instruction code in alu is: tagget")}    
+   //  // is (159.U){ printf("instruction code in alu is: sdd")}    
+       
+   // }
+  //  XSDebug("instruction in alu class1=%b\n",dataModule.io.func)
+  //  XSDebug("instruction in alu class2=%b\n",io.in.bits.uop.ctrl.fuOpType)
+ 
+   //for test
+   CapEModule.io.operand_a := 100230190.U//previous base 100230256.U //shrink
+   CapEModule.io.operand_b := 100230302.U//previous top 100230328//shrink
+   CapEModule.io.imm       :=2.U 
+   CapEModule.io.cap_b     := Cat(0.U(93.W), 0.U(3.W) ,1023.U(31.W))
+   //  CapEModule.io.cap_a     := Cat(31.U(93.W), 2.U(3.W) ,1023.U(31.W))//revoke
+   //  CapEModule.io.cap_a     := Cat(31.U(93.W), 4.U(3.W) ,1023.U(31.W))//clcc
+    CapEModule.io.cap_a     := Cat(31.U(90.W), 1.U(3.W), 1.U(3.W) ,2103.U(31.W))//scc/tighten/split/mov/coffset
+   //  CapEModule.io.cap_a     := Cat(31.U(90.W), 1.U(3.W), 0.U(3.W) ,2103.U(31.W))//scc/tighten/split
+    // CapEModule.io.cap_c     := Cat(31.U(93.W), 0.U(3.W) ,12.U(31.W))//mrev
+   //  CapEModule.io.cap_c     := Cat(cap_compress_cap.cap_cc.bounds.cursor, cap_compress_cap.cap_cc.bounds.bE,cap_compress_cap.cap_cc.bounds.b,cap_compress_cap.cap_cc.bounds.tE,cap_compress_cap.cap_cc.bounds.t,cap_compress_cap.cap_cc.bounds.iE,0.U(3.W), cap_type_t.CAP_TYPE_LINEAR ,0.U(31.W))//for delin
+ 
+   // CapEModule.io.tag_a     := 0.U//delin//revoke/seal
+   CapEModule.io.tag_a     := 1.U//scc/tighten/split/drop/cinit/mrev
+   CapEModule.io.tag_b     := 0.U
+   CapEModule.io.tag_c     := 1.U//shrink
+ 
+   CapEModule.io.rs1    := 1198.U//mov
+   CapEModule.io.rd     := 1345.U//mov
+ 
+    val rs1_cc = Reg(new cap_cc_t)
+    val rs1_c  = Reg(new cap_fat_t) 
+    val cap_uncompress_cap = Module(new cap_uncompress)
+    val cap_compress_cap   = Module(new cap_compress)
+    val rs2_c  = Reg(new cap_fat_t) 
+    rs1_c.bounds.cursor:=100230256.U//100231256.U//807661056.U//"h00df000000121400".U//1400.U//
+    rs1_c.bounds.base  :=100230132.U//100230132.U//807660032.U//"h00df000000121000".U//1000.U//
+    rs1_c.bounds.top   :=100230328.U//100234228.U//807664128.U//"h00df000000122000".U//2000.U//
             
-   rs1_c.renode_id:=12.U
-
-   cap_compress_cap.cap_fat.bounds.cursor:=rs1_c.bounds.cursor
-   cap_compress_cap.cap_fat.bounds.base  :=rs1_c.bounds.base
-   cap_compress_cap.cap_fat.bounds.top   :=rs1_c.bounds.top
-   cap_compress_cap.cap_fat.renode_id   :=rs1_c.renode_id
-   cap_compress_cap.cap_fat.reg_id:=rs1_c.reg_id
-   cap_compress_cap.cap_fat.async:=rs1_c.async
-   cap_compress_cap.cap_fat.padding:=rs1_c.padding
-   cap_compress_cap.cap_fat.meta.ty:=rs1_c.meta.ty
-   cap_compress_cap.cap_fat.meta.perm:=rs1_c.meta.perm
-   cap_compress_cap.cap_fat.renode_id:=rs1_c.renode_id
-
-   rs1_cc.bounds.iE:= cap_compress_cap.cap_cc.bounds.iE
-   rs1_cc.bounds.t:= cap_compress_cap.cap_cc.bounds.t
-   rs1_cc.bounds.tE:= cap_compress_cap.cap_cc.bounds.tE
-   rs1_cc.bounds.b:= cap_compress_cap.cap_cc.bounds.b
-   rs1_cc.bounds.bE:= cap_compress_cap.cap_cc.bounds.bE
-   rs1_cc.bounds.cursor := cap_compress_cap.cap_cc.bounds.cursor
-   rs1_cc.meta.ty:= cap_compress_cap.cap_cc.meta.ty
-   rs1_cc.meta.perm:= cap_compress_cap.cap_cc.meta.perm
-   rs1_cc.renode_id:= cap_compress_cap.cap_cc.renode_id
-
-   cap_uncompress_cap.cap_cc.bounds.iE:=rs1_cc.bounds.iE
-   cap_uncompress_cap.cap_cc.bounds.t:=rs1_cc.bounds.t
-   cap_uncompress_cap.cap_cc.bounds.tE:=rs1_cc.bounds.tE
-   cap_uncompress_cap.cap_cc.bounds.b:=rs1_cc.bounds.b
-   cap_uncompress_cap.cap_cc.bounds.bE:=rs1_cc.bounds.bE   
-   cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
-   cap_uncompress_cap.cap_cc.meta.ty:=rs1_cc.meta.ty
-   cap_uncompress_cap.cap_cc.meta.perm:=rs1_cc.meta.perm
-   cap_uncompress_cap.cap_cc.renode_id:=rs1_cc.renode_id
-   
-   rs2_c.bounds.base := cap_uncompress_cap.cap_fat.bounds.base
-   rs2_c.bounds.top := cap_uncompress_cap.cap_fat.bounds.top
-   rs2_c.bounds.cursor := cap_uncompress_cap.cap_fat.bounds.cursor   
-   rs2_c.renode_id := cap_uncompress_cap.cap_fat.renode_id
-   rs2_c.reg_id := cap_uncompress_cap.cap_fat.reg_id
-   rs2_c.async:= cap_uncompress_cap.cap_fat.async
-   rs2_c.padding:= cap_uncompress_cap.cap_fat.padding
-   rs2_c.meta.perm:= cap_uncompress_cap.cap_fat.meta.perm
-   rs2_c.meta.ty:= cap_uncompress_cap.cap_fat.meta.ty
-
-   XSDebug("origin uncompress data.top=  %b\n",rs1_c.bounds.top)
-   XSDebug("last uncompress data.top=%b\n",cap_uncompress_cap.cap_fat.bounds.top)
-
-   XSDebug("origin uncompress data.cursor=  %b\n", rs1_c.bounds.cursor)
-   XSDebug("last uncompress data.cursor=%b\n",cap_uncompress_cap.cap_fat.bounds.cursor)
-
-   XSDebug("origin uncompress data.base=  %b\n",rs1_c.bounds.base) 
-   XSDebug("last uncompress data.base=%b\n",cap_uncompress_cap.cap_fat.bounds.base)
+    rs1_c.reg_id:= 3.U
+    rs1_c.async:= 1.U
+    rs1_c.padding:=0.U
+    rs1_c.meta.ty:= cap_type_t.CAP_TYPE_REVOKE
+    rs1_c.meta.perm:= cap_perm_t.CAP_PERM_RWX
+ 
+    rs1_c.renode_id:=12.U
+ 
+    cap_compress_cap.cap_fat.bounds.cursor:=rs1_c.bounds.cursor
+    cap_compress_cap.cap_fat.bounds.base  :=rs1_c.bounds.base
+    cap_compress_cap.cap_fat.bounds.top   :=rs1_c.bounds.top
+    cap_compress_cap.cap_fat.renode_id   :=rs1_c.renode_id
+    cap_compress_cap.cap_fat.reg_id:=rs1_c.reg_id
+    cap_compress_cap.cap_fat.async:=rs1_c.async
+    cap_compress_cap.cap_fat.padding:=rs1_c.padding
+    cap_compress_cap.cap_fat.meta.ty:=rs1_c.meta.ty
+    cap_compress_cap.cap_fat.meta.perm:=rs1_c.meta.perm
+    cap_compress_cap.cap_fat.renode_id:=rs1_c.renode_id
+ 
+    rs1_cc.bounds.iE     := cap_compress_cap.cap_cc.bounds.iE
+    rs1_cc.bounds.t      := cap_compress_cap.cap_cc.bounds.t
+    rs1_cc.bounds.tE     := cap_compress_cap.cap_cc.bounds.tE
+    rs1_cc.bounds.b      := cap_compress_cap.cap_cc.bounds.b
+    rs1_cc.bounds.bE     := cap_compress_cap.cap_cc.bounds.bE
+    rs1_cc.bounds.cursor := cap_compress_cap.cap_cc.bounds.cursor
+    rs1_cc.meta.ty       := cap_compress_cap.cap_cc.meta.ty
+    rs1_cc.meta.perm     := cap_compress_cap.cap_cc.meta.perm
+    rs1_cc.renode_id     := cap_compress_cap.cap_cc.renode_id
+ 
+    //for shrink
+    when (rs1_c.bounds.base===cap_uncompress_cap.cap_fat.bounds.base)
+    {
+    CapEModule.io.cap_c:= Cat(cap_compress_cap.cap_cc.bounds.cursor, cap_compress_cap.cap_cc.bounds.bE,cap_compress_cap.cap_cc.bounds.b,cap_compress_cap.cap_cc.bounds.tE,cap_compress_cap.cap_cc.bounds.t,cap_compress_cap.cap_cc.bounds.iE,0.U(3.W), 0.U(3.W) ,34789.U(31.W))//for shrink
+    XSDebug("CapEModule.io.cap_c=  %b\n",CapEModule.io.cap_c)
+ 
+    XSDebug("origin uncompress data.top=%b\n",rs1_c.bounds.top)
+    XSDebug("last uncompress data.top=%b\n",cap_uncompress_cap.cap_fat.bounds.top)
+ 
+    XSDebug("origin uncompress data.cursor=%b\n", rs1_c.bounds.cursor)
+    XSDebug("last uncompress data.cursor=%b\n",cap_uncompress_cap.cap_fat.bounds.cursor)
+ 
+    XSDebug("origin uncompress data.base=%b\n",rs1_c.bounds.base) 
+    XSDebug("last uncompress data.base=%b\n",cap_uncompress_cap.cap_fat.bounds.base)
+    
+    }
+    .otherwise
+    {
+     XSDebug("origin uncompress data not equal\n") 
+     CapEModule.io.cap_c:=0.U
+     }
+    XSDebug("origin2 uncompress data.top=%b\n",rs1_c.bounds.top)
+    XSDebug("last2 uncompress data.top=%b\n",cap_uncompress_cap.cap_fat.bounds.top)
+ 
+    cap_uncompress_cap.cap_cc.bounds.iE    :=rs1_cc.bounds.iE
+    cap_uncompress_cap.cap_cc.bounds.t     :=rs1_cc.bounds.t
+    cap_uncompress_cap.cap_cc.bounds.tE    :=rs1_cc.bounds.tE
+    cap_uncompress_cap.cap_cc.bounds.b     :=rs1_cc.bounds.b
+    cap_uncompress_cap.cap_cc.bounds.bE    :=rs1_cc.bounds.bE   
+    cap_uncompress_cap.cap_cc.bounds.cursor:=rs1_cc.bounds.cursor
+    cap_uncompress_cap.cap_cc.meta.ty      :=rs1_cc.meta.ty
+    cap_uncompress_cap.cap_cc.meta.perm    :=rs1_cc.meta.perm
+    cap_uncompress_cap.cap_cc.renode_id    :=rs1_cc.renode_id
+    
+    rs2_c.bounds.base    := cap_uncompress_cap.cap_fat.bounds.base
+    rs2_c.bounds.top     := cap_uncompress_cap.cap_fat.bounds.top
+    rs2_c.bounds.cursor  := cap_uncompress_cap.cap_fat.bounds.cursor   
+    rs2_c.renode_id      := cap_uncompress_cap.cap_fat.renode_id
+    rs2_c.reg_id         := cap_uncompress_cap.cap_fat.reg_id
+    rs2_c.async          := cap_uncompress_cap.cap_fat.async
+    rs2_c.padding        := cap_uncompress_cap.cap_fat.padding
+    rs2_c.meta.perm      := cap_uncompress_cap.cap_fat.meta.perm
+    rs2_c.meta.ty        := cap_uncompress_cap.cap_fat.meta.ty
+ 
+    
+ ///end test
    
-///end test
-  
 }
-- 
2.34.1

